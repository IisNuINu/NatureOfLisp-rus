<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<title>defmacro - The Nature of Lisp</title>
		<meta name="description" content="An article about Lisp programming language.">
		<link rel="stylesheet" type="text/css" href="defmacro%20-%20The%20Nature%20of%20Lisp_files/main.css" media="screen">
		<link rel="stylesheet" type="text/css" href="defmacro%20-%20The%20Nature%20of%20Lisp_files/articles.css" media="screen">
		<link rel="stylesheet" type="text/css" href="defmacro%20-%20The%20Nature%20of%20Lisp_files/print.css" media="print">
		<link rel="alternate" type="application/rss+xml" title="defmacro.org" href="http://www.defmacro.org/rss/news.xml">
		<link rel="home" href="http://www.defmacro.org/index.html">

		<style type="text/css">
			.list {
				font-weight: bold;
			}
			.inner-list {
				color: red;
			}
			.inner-inner-list {
				color: blue;
				font-weight: bold;
			}
		</style>

	</head><style type="text/css" id="block-image-video"> svg {visibility: hidden !important; opacity: 0 !important}  img {visibility: hidden !important; opacity: 0 !important}  video {visibility: hidden !important; opacity: 0 !important}  canvas {visibility: hidden !important; opacity: 0 !important}  iframe [type="application/x-shockwave-flash"] {visibility: hidden !important; opacity: 0 !important}  .hide {visibility: hidden !important; opacity: 0 !important} </style>
	<body>
		<div id="wrapper"><div id="wrapper1"><div id="wrapper2"><div id="wrapper3">
			<div id="page-extra-1"><div id="page-extra-2"><div id="page-extra-3">&nbsp;</div></div></div>
			<div id="wrapper4">
			<div id="header">
				<div id="header-extra-1">
				<div id="header-extra-2">
				<div id="header-extra-3">
				<div id="header-extra-4">
					<div id="header-extra-5">
					  <a class="home" href="http://www.defmacro.org/">Home - defmacro.org</a>
					  <span id="title">Made with alien technology.</span>
						<div id="syndication"><a href="http://www.defmacro.org/rss/news.xml" title="RSS Feed"><img src="../images/xml.png" alt="RSS Feed"></a></div>
					</div>
				</div>
				</div>
				</div>
				</div>
			</div>
			<div id="content">
				<h1>Природа Лиспа (The Nature of Lisp)</h1>
				<div class="date">Monday, May 8, 2006</div>

				<h2><a id="part_1">Введение</a></h2>
				<p class="first">Когда я столкнулся с пропагандой Лиспа в разных
уголках сети, я был уже опытным программистом. В тот момент я ухватился за то, что в то время казалось
широким спектром языков программирования. Я гордился тем, что в моем послужном списке значились (C++, 
Java, C#, и иже с ними.), и у меня сложилось впечатление, что я знаю ВСЁ, что нужно знать о языках
программирования. Как же я был тогда не прав.</p>

<p>Моя первая попытка изучить Лисп потерпела крах, как только я увидел пример кода. Я полагаю, что
в моей голове возникла та же мысль, которая пронзила тысячи других людей, которые когда либо были
в моем положении: "С какой стати кто-то захочет использовать язык с таким ужасным синтаксисом?!".
Я не буду изучать язык, если его создатели не удосужились дать ему приятный для пользователя синтаксис. 
В конце концов, я был почти ослеплен печально известными скобками Лиспа!</p>

<p>В тот момент, когда я вновь обрел зрение, я сообщил о своих разочарованиях некоторым членам
секты Лисп. Почти сразу же я был засыпан стандартным набором ответов: круглые скобки Лиспа это
не существенный вопрос, Лисп имеет огромное преимущество перед другими языками выражая данные
и код одинаковым способом. (что, очевидно, является огромным улучшением по сравнению с XML), 
Лисп имеет невероятно мощные средства метапрограммирования, которые позволяют программам
писать код и изменять себя, Лисп позволяет создавать мини-языки, узкоспецифичные для рассматриваемой
проблемы, Лисп стирает различия между временем выполенния и временем компиляции, Лисп, Лисп, Лисп .....
Список был очень впечатляющим. Излишне говорить, что ничего из этого для меня не имело смысла. 
Никто не мог проилюстрировать полезность этих функций конкретными примерами, потому что эти методы
предположительно полезны только в больших программных системах. 
После многих часов дискуссий о том, что обычные языки программирования отлично справляются со своими
задачами, я сдался. Я не собирался тратить месяцы на изучение языка с ужасным синтаксисом, чтобы понять
неясные особенности, которые не имели полезных и ясных примеров. Мое время еще не пришло!
</p>

<p>В течении многих месяцев сторонники Лиспа продолжали свою коварную агитацию. 
Я был сбит с толку. Многие чрезвычайно умные люди, которых я знал и которых очень уважал,
восхаляли ЛИСП, почти с религиозной преданностью. Там должно было быть что-то, и я не мог
позволить себе упустить ЭТУ божественную тайну из своих рук! В конце концов моя жажда знаний победила меня.
Я сделал решающий шаг, закусив удила, закатав рукава начал месяцами выполнять упражнения
выворачивающие мне мозг. Это было путешествие по бесконечному озеру разочарования.
Я вывернул свой разум наизнанку, промыл его и поставил на место. Я прошел через семь
кругов ада и вернулся. И тогда я получил ЭТО!
</p>

<p>Просветление пришло внезапно. В один момент я ничего не понимал, а в следующий все встало на свои
места. Я достиг нирваны. Десятки раз я слышал слова Эрика Рэймонда, цитируемые разными людьми: "Лиспу
стоит учиться для обретения того глубокого просветления, которое вы получите в конце обучения(возможно
получите); и этот опыт сделает вас лучшим программистом до конца ваших дней, даже если вы на самом деле
никогда не воспользуетесь самим Лиспом." Я никогда не понимал этого утверждения. Я никогда не верил, что
это может быть правдой. и наконец, после всей боли, оно обрело смысл! В нем было больше правды, чем
я мог себе представить. Я достиг почти божественного состояния ума, мгновенного опыта просветления,
который перевернул мой взгляд на информатику с ног на голову менее чем за одну секунду.
</p>

<p>В туже секунду я стал членом культа Лиспа. Я чувствовал что-то, что должен чувствовать мастер
ниндзюцу: Я должен был распространить свои обретенные знания по крайней мере на десять потерянных
душ в течение моей жизни. Вначале я выбрал обычный путь. Я перефразировал те же аргументы, которыми
меня пичкали годами (только теперь они действительно имели для меня смысл!), 
надеясь обратить в свою веру, ни в чем не подозревающих прохожих, но это не сработало! Моя настойчивость
вызвала интерес нескольких людей, но их любопытство угасло, при виде простого примера кода на Лиспе.
Возможно, годы пропаганды выковали бы несколько новых Лисперов, но я не был бы этим удовлетворен. 
Должен был быть лучший способ.
</p>

<p>Я тщательно обдумал этот вопрос. Есть ли в Лиспе что-то сложное, что мешает очень умным, опытным
программистам понять это? Нет! В конце концов, я же получил это, и если я смог сделать это, любой
сможет. Тогда что же делает Лисп делает таким трудным для понимания? Ответ, как обычно делают такие
вещи, пришел неожиданно. Конечно! Обучение кого-либо чему-либо включает в себя построение передовых
концепций поверх тех концепций, которые они уже понимают! Если процесс становится интересным, и вопрос
объясняется должным образом, новые концепции становятся такими же интуитивными, как и исходные 
строительные блоки, которые помогают их пониманию. Это была проблема! 
Метапрограммирование, единообразное представление кода и данных, самоизменяющиеся программы, предметно ориентированные мини языки(DSL), ни одно из объяснений этих концепций не относятся к территории знакомой
обычному программисту. Как я мог ожидать, что кто-нибудь поймет их?! Неудивительно, что люди хотели
конкретных примеров. С таким же успехом я мог бы говорить по марсиански!
</p>

<p>Я поделился своими идеями со знакомыми Лисперами. "Ну конечно, эти понятия не объясняются
с точки зрениия привычных практик обычных программистов", сказали они. "Они настолько иные,
настолько непохожи ни на что, чему эти люди учились ранее". Это было плохое оправдание. 
"Я не верю, что это правда", сказал я. Ответ был единодушным: "Почему бы тебе не попробовать?".
Так я и сделал. Эта статья является продуктом моих усилий. Это моя попытка объяснить Лисп, в 
терминах знакомых, интуитивных понятий. Я призываю храбрые души читать дальше. Взять свой любмый
напиток, сделать глубокий вдох. Приготовиться к тому, что вас унесет ветром.  О, и да пребудет
с вами Сила.
</p>

				<h2><a id="part_2">XML Перезагрузка</a></h2>
				<p class="first">Путешествие в тысячу миль начинается с одного шага. 
Путь к просветелению не является исключением, и наш первый шаг - это XML. Что можно еще сказать о
XML, чего еще не было сказано? Оказывается, совсем не много. Хотя нет ничего осоебнно интересного в
самом XML, его отношение к Лиспу впечатляет. XML - это слишком знакомая концепция, в которой так нуждается
сторонник Лиспа. Это наш мост для передачи ПОНИМАНИЯ обычным программистам. Итак, давайте возродим мертвую
лошадь, вытащим кнут и отправимся в дикую природу XML, в которую никто не осмеливался сунуться до нас. Пришло
время увидеть слишком знакомую луну с ДРУГОЙ стороны.
</p>

<p>Внешне XML - это не что иное, как стандартизированный синтаксис, используемый для выражения
произвольных иерархических данных в удобочитаемой форме. Списки дел, веб страницы, медицинские
записи, страховые возмещения, файлы конфигурации - всё это примеры потенциального использоания XML. 
Давайте используем простой список дел в качестве примера (в нескольких разделах вы увидите его
в совершенно новом свете):
</p>

<pre>&lt;todo name="housework"&gt;
    &lt;item priority="high"&gt;Clean the house.&lt;/item&gt;
    &lt;item priority="medium"&gt;Wash the dishes.&lt;/item&gt;
    &lt;item priority="medium"&gt;Buy more soap.&lt;/item&gt;
&lt;/todo&gt;
</pre>

<p>Что произойдет, если мы применим наш любмый анализатор(парсер) XML к этому списку дел? 
Как только данные проанализируются, как они разместятся в памяти? Конечно, наиболее естественным
представлением является дерево - идеальная структура данных для иерархических данных. После всего
сказанного и сделанного, XML на самом деле представляет собой просто дерево, сериализованное
в удобочитаемую форму. Все что может быть представлено в виде дерева, может быть представлено в
XML и наоборот. Я надеюсь вы понимаете эту идею. Это очень важно, для понимания того, что будет
дальше.
</p>

<p>Давайте рассмотрим это немного дальше. Какой другой тип данных часто представляется в виде дерева?
На данный момент этот список практически бесконечен, поэтому я дам вам подсказку, к чему я клоню -
попробуйте вспомнить ваш старый курс по компиляторам. Если у вас есть смутное воспоминание о том, что
исходный код сохраняется в виде дерева после анализа, вы на правильном пути. Любой комплятор неизбежно
анализирует исходный код в абстрактном синтаксическом дереве(AST). Это неудивительно, поскольку сам исходный
код является иерархическим: функции содержат арументы и блоки кода. Блоки кода содержат выражения и операторы. Выражения содержат переменные и операторы. И так далее.
</p>

<p>Давайте применим наше заключение о том, что любое дерево может быть легко преобразовано в
XML для этой идеи. Если весь исходный код в конечном итоге представляется в виде дерева, и любое
дерево может быть сериализовано в  XML, то весь исходный код можно преобразовать в XML, верно? 
Давайте проилиюстрируем это интересное свойство на простом примере. Рассмотрим функцию ниже:
</p>

<pre>				
int add(int arg1, int arg2)
{
    return arg1 + arg2;
}
</pre>			

<p>Можете ли вы преобразовать это определение функции в его XML эквивалент? Оказывается, это
достаточно просто. Естественно, есть много способов сделать это. Вот один из этих способов,
применением которого полученный XML может выглядеть так:
</p>

<pre>&lt;define-function return-type="int" name="add"&gt;
    &lt;arguments&gt;
        &lt;argument type="int"&gt;arg1&lt;/argument&gt;
        &lt;argument type="int"&gt;arg2&lt;/argument&gt;
    &lt;/arguments&gt;
    &lt;body&gt;
        &lt;return&gt;
            &lt;add value1="arg1" value2="arg2" /&gt;
        &lt;/return&gt;
    &lt;/body&gt;
&lt;/define&gt;
</pre>

<p>Мы можем пройти это относительно простое упражнение на любом языке. Мы можем превратить
любой исходный код в XML.

и преобразовать полученный XML обратно в исходный код. Мы можем написать конвертер, который
превращает Java в XML и конвертер, который превращает XML обратно в Java. Мы могли бы сделать
тоже самое для C++. (В случае если вам интересно, достаточно ли это безумно, чтобы делать это,
взгляните на <a href="http://www.gccxml.org/">GCC-XML</a>).

Кроме того, для языков, которые имеют общие функции, но используют другой синтаксис (что в некоторой
степени верно для большинства основных языков), мы можем преобразовать исходный код с одного языка на
другой используя XML в качестве промежуточного представления. Мы могли бы использовать наш конвертер 
Java2XML для преобразования программы Java в XML. Затем мы могли бы запустить конвертер XML2CPP для
полученного XML и превратить его в код на C++. Если повезет (если мы будем избегать использования
специфичных  функций Java, которых нет в C++), мы получим работающую программу на C++. Ловко, а?</p>

<p>Все это фактически означает, что мы можем использовать XML как общее хранилище исходного кода. 
Мы можем создать целый класс языков программирования, которые используют унифицированный синтаксис,
а также написать преобразователи, котоыре преобразуют существующий исходный код в XML. Если бы мы
на самом деле приняли эту идею, компиляторы разных языков не должны были бы реализовывать парсеры
(анализаторы) для своих конкретных граматик - они просто использовали бы парсер XML, чтобы превратить
XML непосредственно в абстрактное синтаксическое дерево.
</p>

<p>К настоящему времени вы, вероятно, задаетесь вопросом, почему я начал "крестовый" поход на
XML и как он связан с Лиспом.(в конце концов, Лисп был создан примерно за 30 лет до появления
XML). Обещаю, что скоро все станет ясно. Но прежде чем мы сделаем второй шаг, давайте пройдем
небольшое филосовское упражнение. Внимательно посмотрите на  XML версию нашей функции "add",
приведенной выше. Как бы вы её классифицировали? Это данные или код? Если вы задумаетесь об
этом на мгновение, вы поймете, что есть веские причины для помещения этого фрагмента XML 
в обе категории. Это XML, и это просто информация , закодированная в стандартном формате.
Мы уже определили, что она может быть сгенерирована из древовидной структуры данных в памяти
(это, фактически, то что делает GCC-XML). Она лежит в файле без видимого способа её выполнения.
Мы можем разобрать ее в дерево узлов XML и сделать с ним различные преобразования. Это данные. 
Но подождите минутку! Когда все сказано и сделано, это таже самая функция "add", написанная
другим синтаксисом, верно? После ее анализа, дерево может быть передано в компилятор, и мы сможем
выполнить её. Мы могли бы легко написать небольшой интерпретатор дя этого XML кода и выполнять
его напрямую. В качестве альтернативы, мы могли бы преобразовать его в код Java или C++, 
скомпилировать его, и запустить. Это код.
</p>

<p>Итак, где мы? Похоже мы пришли к интересному положению. Концепция, которую раньше было так сложно
понять, теперь удивительно проста и интуитивно понятна. Код это тоже всегда  данные! 
Означает ли это, что данные это всегда код? Как бы безумно это не звучало, но это вполне может иметь
место. Помните, как я обещал, что вы увидите наш список дел в совершенно новом свете? Позвольте мне 
повторить это обещание. Но пока мы не готовы обсуждать это. А пока давайте продолжим идти по нашему
пути.
</p>

<p>Чуть раньше я упомянул, что мы могли бы написать интерпретатор для выполнения нашего
фрагмента XML функции add. Конечно, это звучит как чисто теоретическое упражнение. Кто в здравом
уме захочет сделать это в практических целях? Что ж, оказывается, довольно много людей с этим
не согласились. Скорее всего, вы встречали и использовали их работу хотябы раз в своей карьере.
Вы еще не ушли? Если так, давайте двигаться дальше!
</p>

				<h2><a id="part_3">Ant Перезагрузка</a></h2>
				<p class="first">Теперь, когда мы совершили путешествие на темную
строну луны, давайте пока не будет отсюда уходить. Мы все еще можем чему-то научиться, проводя наши 
исследования немного глубже. Мы начнем с того, что закроем глаза и вспомним холодную дождливую ночь зимой 2000
года. Известный разработчик Джеймс Дункан Девидсон(James Duncan Davidson)<sup><a href="#note-james">1</a></sup> 
пробирался через контейнер сервлетов <a href="http://tomcat.apache.org/">Tomcat</a>. Когда пришло время
сохранить изменения, он тщательно сохранил все свои файлы и запустил <em>make</em>. Ошибки. МНОГО ошибок. 
Что-то пошло не так! После тщательного изучения проблемы Джеймс воскликнул: "Моя команда не выполняется,
потому что у меня стоит пробел перед моей табуляцией(в команде make)?!". Действительно, это была проблема.
Потом опять. С Джемса этого было достаточно. Он смог почувствовать холодную луну сквозь облака и это сделало
его авантюристом. Он создал свежий Java проект и быстро собрал простую, но удивительно полезную утилиту.
Эта искра гения использовала файлы свойств Java для получения информации о том, как строить проект. Теперь
Джеймс мог написать эквивалент makefile в хорошем формате, не беспокоясь о проклятых пробелах. Его утилита
выполняла всю тяжелую работу, интерпретируя файл свойств и выполняя соответствующие действия для построения
проекта. Это было ловко! Еще один Ловкий инструмент(Another Neat Tool). <a href="http://ant.apache.org/">Ant</a>.
</p>

<p>После использования Ant для сборки Tomcat в течении нескольких месяцев стало ясно, что файлов
свойств Java недостаточно для выражения сложных инструкций по сборке. Файлы должны быть проверены,
скопированы, скомпилированы, отправлены на другой компьютер и протестированы. В случае неудачи
электронные письма должны быть отправлены соответствующим людям. В случае успеха "Bad to the Bone"
нужно было играть с максимально возможной громкостью. В конце трека громкость нужно было восстанавливать
до исходного уровня. Да, файлов свойств Java уже было маловато. Джеймсу необхдимо было более гибкое
решение. Ему не хотелось писать собственный парсер (тем более, что он хотел стандартного решения). 
XML казался разумной альтернативой. Через пару дней Ant был перенесен на XML. Это была лучшая вещь
со времен изобретения нарезанного хлеба(присказка такая английская, используемая для того чтобы
показать маштаб/величину/значение проделанной работы).</p>

<p>Так как работает Ant? Это довольно просто. Он берет файл XML со специальными инструкциями по
сборке (вы уж сами решайте, являются ли они данными или кодом) и интерпретирует их, выполняя
специализированный код Java для каждого элемента XML. Это на много проще, чем кажется. Простая
инструкция XML подобная приведенной ниже, вызывает загрузку Java класса с эквивалентным именем
и выполнение его кода.
</p>

<pre>&lt;copy todir="../new/dir"&gt;
    &lt;fileset dir="src_dir"/&gt;
&lt;/copy&gt;
</pre>

<p>Приведенный выше фрагмент кода копирует исходный каталог в целевой каталог. Ant находит задачу
"copy"  (на самом деле класс Java), устанавливает соответствующие параметры (todir и fileset), 
вызывая соответствующие методы Java, а затем выполняет задачу. Ant поставляется с набором основных
задач, и любой может расширить его своими собственными задачами, просто написав Java классы, которые
следуют определенным соглашениям. Ant находит эти классы и выполняет их всякий раз, когда встречаются
элементы XML с соответствующими именами. Довольно просто. По сути, Ant выполняет то, о чем мы говорили
в предыдущем разделе: он выступает в роли интерпретатора языка, который использует XML в качестве
синтаксиса, переводя элементы XML в соответствующие инструкции Java. Мы могли бы написать задачу "add"
и заставить Ant выполнить её при обнаружении фрагмента XML для добавления, представленного в предыдущем
разделе! 
Учитывая, что Ant - чрезвычайно популярный проект, идеи представленные в предыдущем разделе, начинают
казаться более разумными. В конце концов, они используются каждый день в том, что вероятно, работает
в тысячах компаний!
</p>

<p>До сих пор я ничего не говорил, почему Ant на самом деле проходит через все трудности
интерпретации XML. Не пытайтесь искать ответ на его веб сайте - вы не найдете ничего ценного. 
Во всяком случае, ничего общего с нашей дисскусией. Давайте сделаем еще один шаг.
Пришло время выяснить, ПОЧЕМУ.
</p>

				<h2><a id="part_4">Почему XML?</a></h2>
				<p class="first">Иногда правильные решения принимаются без полного
осознанного понимания всех проблем. Я не уверен, знал ли Джеймс, почему он выбрал  XML - это было,
вероятно подсознательное решение. По крайней мере, причины, которые я видел на веб-сайте Ant 
обосновывающие использование XML, - это не правильные причины. Похоже, что основные проблемы были
связаны с переносимостью и расширяемостью. Я не понимаю, как XML помогает продвигать эти цели в 
случае с Ant. В чем преимущество использования интерпретируемого XML над простым исходным кодом
Java?
Почему бы не создать набор классов с хорошим API(как это сделано в ASDF) для часто используемых
задач (копирования каталогов, компилирования и т.д.) и использовать их непосредственно из
исходного кода Java? Это будет работать на любой платформе Java(которая в любом случае требуется
для Ant/прим. переводчика: на самом деле это будет работать, только на платформах где установлен 
компилятор Java, а для работы ant достаточно виртуальной машины Java), он(код) бесконечно расширяем
и имеет преимущество, заключающееся в более приятном, знакомом синтаксисе. Так почему же XML? 
Можем ли мы найти вескую причину для его использования?
</p>

<p>Оказывается, МОЖЕМ!(хотя, как я упоминал ранее, я не уверен, осознавал ли это Джеймс). 
У XML есть свойство быть гораздо более гибким с точки зрения введения семантических
конструкций, чем Java могла бы когда либо надеятся. Не волнуйтесь, я не попаду в ловушку
использования громких слов для описания непонятных понятий. На самом деле это относительно
простая идея, хотя для её объяснения может потребоваться некоторое усилие. Пристегните
ремень безопасности. Мы собираемся совершить гиганский скачок к достижению нирваны.
</p>

<p>Как мы можем представить пример копирования - 'copy' в виде кода Java? Вот один из
способов сделать это:</p>

<pre>CopyTask copy = new CopyTask();
Fileset fileset = new Fileset();

fileset.setDir("src_dir");
copy.setToDir("../new/dir");
copy.setFileset(fileset);

copy.execute();
</pre>

<p>Код почти такой же, хотя и немного длиннее исходного XML. Так что же отличается? Ответ заключается
в том, что фрагмент XML вводит(представляет) специальную семантическую конструкцию для копирования.
Если бы мы могли сделать это на Java, это выглядело бы так:</p>

<pre>		
copy("../new/dir")
{
    fileset("src_dir");
}
</pre>				

<p>Вы видите разницу? Приведенный выше код (если бы это было возможно в Java) представляет собой
специальный оператор для копирования файлов - аналогичный циклу <em>for</em> или новой конструкции
<em>foreach</em>, представленной в Java 5. Если бы у нас был автоматический преобразователь из XML
в Java, он скорее всего, произвел бы описанную выше тарабарщину. Причина этого заключается в том,
что принятая граматика синтаксического дерева Java фиксируется спецификацией языка - у нас нет
способа её изменить. Мы можем добавлять пакеты, классы, методы, но мы не можем расширять Java,
чтобы сделать возможным добавление новых операторов. Тем не менее, мы можем делать это,
сколько душе угодно, в XML - его синтаксическое дерево не ограничено ничем, кроме нашего
интерпретатора! Если идея все еще не ясна, подумайте о введении специального оператора (если не) 'unless'
в Java:
</p>

<pre>				
unless(someObject.canFly())
{
    someObject.transportByGround();
}
</pre>				

<p>В предыдущих двух примерах мы расширили язык Java, введя оператор для копирования файлов и
условный оператор "если не"(<em>unless</em>). Мы сделали это изменив граматику абстрактного синтаксического
дерева, которую принимает компилятор Java. Естественно, мы не можем сделать это стандартными средствами Java,
но мы можем легко это сделать в XML. Поскольку наш интерпретатор XML анализирует полученное в результате
абстрактное синтаксическое дерево, мы можем расширить его, включив в него любой понравившийся нам оператор.
</p>

<p>Для сложных операторов эта возможность дает огромные преимущества. Можете ли вы представить
написание специальных операторов для проверки исходного кода, компиляции файлов, запуска
модульного тестирования, отправки электронной почты? Попробуйте что-нибудь придумать. 
Если вы имеете дело со специализированной проблемой (в нашем случае это построение прокетов) 
эти операторы могут творить чудеса, чтобы уменьшить количество кода, который вы
должны ввести, и увеличивают ясность и повторное использование кода. Интепретируемый XML
делай это чрезвычайно легким для выполнения, потому что это простой файл данных, который
хранит иерархические данные. У нас нет такой возможности в Java, потому что её иерархческая
структура ограничена (как вы скоро узнаете, у нас есть такая возможность/опция в Лиспе). 
Возможно, это одна из причин, почему  Ant так успешен?
</p>

<p>Я призываю вас взглянуть на недавнюю эволюцию Java и C# (особенно недавно выпущенную
спецификацию для C# 3.0). Языки развиваются путем абстрагирования часто используемых
функций и добавления их в форме операторов. Новые операторы C# для встроенных запросов -
это один из примеров. Это достигается относительно традиционными средствами: создатели
языка модифицируют принимаемое абстрактное синтаксическое дерево и добавляют реализации
определенных функций. Представьте себе возможности, если программист сам мог бы изменять
абстрактное синтаксическое дерево! Полностю новые субязыки могут быть созданы для 
специализированных доменов(предметных областей)(например, язык для создания проектов,
такой как Ant). Можете ли вы придумать другие примеры? Подумайте немного об этих понятиях,
но не слишком переживайте о них. Мы вернемся к этим вопросам после того, как представим
еще несколько идей. К тому времени все станет намного яснее.
</p>

				<h2><a id="part_5">Почти Lisp</a></h2>
				<p class="first">Давайте на время забудем о построении операторов и
попытаемся расширить наши горизонты за пределы ограничений дизайна Ant. Ранее я упоминал, что Ant
можно расширить, написав обычные классы Java. Затем интерпретатор Ant пытается сопоставить элементы
XML с соответствующими именами Java классов, и, если совпадение найдено, задача выполняется.
Напрашивается интересный вопрос. Почему бы не расширить Ant в самом Ant? В конце концов, основные
задачи содержат много традиционных конструкций языка программирования ('if' - прекрасный пример).
Если бы Ant предоставил конструкции для разработки задач в самом Ant, мы бы  достигли более высокой
степени переносимости. Мы бы зависели от основного набора задач (стандартной библиотеки, если хотите)
и нам было бы все равно, присутствуют ли средства времени выполнения Java: базовый набор может быть
реализован на любом языке, любой платформы. Остальные задачи будут построены поверх ядра с использованием 
самого Ant-XML. Тогда Ant станет общим расширяемым языком программирования на основе XML. Рассмотрим
возможности:
</p>

<pre>&lt;task name="Test"&gt;
    &lt;echo message="Hello World!"/&gt;
&lt;/task&gt;
&lt;Test /&gt;
</pre>

<p>
Если ant поддерживает конструкцию "task", в приведенном выше примере будет напечатано 
"Hello World!". Фактически, мы могли бы написать задачу("task") на  Java и сделать Ant
способным расширять себя, используя Ant-XML! Тогда Ant сможет создавать более сложные
примитивы поверх простых, как и любой язык программирования! Это прмер языка программирования
на основе "XML", о котором мы говорили в начале этого урока. Не очень полезно (вы можете
сказать почему?), но чертовски круто.
</p>

<p>Кстати, еще раз взгляните на нашу задачу 'Test'.  Поздравляю! Вы
смотрите на код Лисп! О чем я говорю? Это не похоже на Лисп? Не волнуйтесь,
мы это немного исправим. Смущены? Хорошо. Давайте все проясним!</p>

				<h2><a id="part_6">Лучший XML</a></h2>
				<p class="first">В предыдущем разделе я упомянул, что саморасширяющийся
Ant не будет достаточно полезен. Причиной этого является многословие XML. Он не так уж плох для файлов
данных, но в тот момент, когда вы попытаетесь написать достаточно сложный код, количество набираемого
вами текста быстро начинает мешать и становиться непригодным для использования в любом реальном
проекте. Вы когда-нибудь пытались написать сценарий сборки на Ant? Я да, и как только он становится
достаточно сложным, необходимость делать это в  XML становится действительно раздражающей.
Представьте, что вам нужно вводить почти все в Java дважды! Потому что вы должны закрыть каждый
элемент. Разве это не сводит вас с ума?
</p>

<p>Решение этой проблемы включает использование менее подробной альтернативы XML.
Помните, что XML это просто формат данных для представления иерархических данных.
Нам не нужно использовать угловые скобки XML для сериализации деревьев. Мы могли
бы придумать много других форматов. Один из таких форматов (кстати, тот который
использует Лисп) называется s-выражение(s-expression). S-выражения достигают тех
же целей, что и XML. Они намного менее многословны, что делает их намного лучше
подходящими для ввода кода. Я объясню s-выражения через некоторое время, но прежде
чем я это сделаю, я должен разобраться с XML. Давайте рассмотрим наш пример XML
для копирования файлов:
</p>

<pre>&lt;copy todir="../new/dir"&gt;
    &lt;fileset dir="src_dir"/&gt;
&lt;/copy&gt;
</pre>

<p>Подумайте, как будет выглядеть дерево разбора этого фрагмента в памяти. У нас будет узел
'copy', который содержит набор файлов. Но как насчет атрибутов? Как они вписываются в нашу
картину? Если вы когда-либо использовали XML для описания данных и задавались вопросом,
следует использовать элемент или атрубут, вы не одиноки. Никто не может понять это и сделать
это правильно. Как правило это черная магия, а не наука. Причина в том, что атрибуты
в действительности являются подмножеством элементов. Все что могут сделать атрибуты, 
могут сделать и элементы. Причина, по которой были введены атрибуты, заключается в попытке
обуздать многословность XML. Взгляните на другую версию нашего фрагмента 'copy':</p>

<pre>&lt;copy&gt;
    &lt;todir&gt;../new/dir&lt;/todir&gt;
    &lt;fileset&gt;
        &lt;dir&gt;src_dir&lt;/dir&gt;
    &lt;/fileset&gt;
&lt;/copy&gt;
</pre>

<p>Два фрагмента содержат одинаковую информацию. Однако мы используем атрибуты, 
чтобы не вводить одну и туже вещь более одного раза. Представьте, что атрибуты
не являются частью спецификации XML. Написание чего-либо на XML сведет нас с ума!
</p>

<p>Теперь когда мы избавились от атрибутов, давайте посмотрим на  s-выражения.
Причина, по которой мы сделали этот крюк, заключается в том, что s-выражения 
не имеют атрибутов. Поскольку они гораздо менее многословны, атрибуты просто
не нужны. Это та вещь, которую мы должны иметь в виду при преобразовании XML
в s-выражения. Давайте рассмотрим один пример. Мы могли бы преобразовать
приведенный выше фрагмент в s-выражения, подобные этим:</p>

<pre>(copy
    (todir "../new/dir")
    (fileset (dir "src_dir")))
</pre>

<p>Взгляните хорошенько на это представление. А в чем разница? Угловые скобки, по-видимому
заменяются круглыми скобками. Вместо того чтобы заключать каждый элемент в пару скобок
и затем закрывать каждый элемент с помощью "(/element)" мы просто пропускаем вторую
скобку в  "(element" и продолжаем. Затем элемент закрывается следующим образом: ")". 
Вот и все! Преобразование естественное и очень простое. Кроме того, его гораздо
легче печатать. Ослепляют ли скобки в первый раз пользователей? Может быть, но теперь
когда мы понимаем причины, стоящие за этим, с ними гораздо легче справиться.
По крайней мере, они лучше, чем артрит, вызываемый многословием XML. После того,
как вы привыкните к s-выражениям, написание кода на нем, становиться не только выполнимо,
но и приятно. И они предоставляют все преимущества написания кода на XML (многие из
которых нам еще предстоит изучить). Давайте посмотрим на код нашей задачи - 'task' в
чем-то он очень похож на lisp:</p>

<pre>(task (name "Test")
    (echo (message "Hello World!")))

(Test)
</pre>

<p>S-выражения называются списками на языке Lisp. Рассмотрим наш элемент задача-'task', приведнный выше.
Если мы перепишем его без разрыва строки и с разделителями(запятыми) вместо пробелов, то он удивительно
будет похож на список элементов и другие списки (форматирование добавляется, чтобы облегчить
просмотр вложенных списков):</p>

<pre><span class="list">(task,</span> <span class="inner-list">(name, "test")</span>, <span class="inner-inner-list">(echo,</span> <span class="inner-list">(message, "Hello World!")</span><span class="inner-inner-list">)</span><span class="list">)</span>
</pre>

<p>Мы могли бы сделать тоже самое с XML. Конечно, приведенная выше строка на самом деле 
не список, а дерево, как и его XML-альтернатива. Не позволяйте ссылкам на списки
сбивать вас с толку, просто списки, содержащие другие списки и деревья - это
фактически одно и тоже. Lisp может быть и означает Обработка Списков(List Processing),
но на самом деле это может быть и обработка деревьев - она ничем не отличается от
обработки XML узлов.</p>

<p>Вот, как то так. После долгих бессвязных разговоров мы наконец добрались до
чего-то похожего на Lisp (и это на самом деле Lisp). К настоящему времени
загадочные круглые скобки Lisp, а также некоторые утверждения, сделанные
защитниками(пропагандистами) Lisp должны стать более ясными. Но у нас есть
еще много неизведанной территории, чтобы ее освоить. Вы готовы?
Давайте двигаться дальше!</p>

				<h2><a id="part_7">C Macros Перезагрузка</a></h2>
				<p class="first">Теперь вы, должно быть, устали от всех этих
разговоров о XML. Мне это тоже надоело. Пришло время отдохнуть от всех этих деревьев,
s-выражений, и занятий с Ant. Вместо этого давайте вернемся к корням каждого программиста.
Пришло время поговорить о препроцессоре Си. А какое отношение Си имеет ко всему этому,
спросите вы? Что ж, теперь мы знаем достаточно, чтобы занятся метапрограммированием и
обсудить код, который пишет другой код. Понимание этого, как правило, затруднено, так
как все учебники обсуждают его с точки зрения языков, которых вы не знаете. Но в самой
концепции нет ничего сложного. Я полагаю, что обсуждение метапрограммирования, основанного
на Си, сделает все это гораздо более понятным. Итак, давайте посмотрим (pun intended).</p>

<p>Зачем кому-то писать программу, которая пише программы? Как мы можем использовать
что-то подобное в реальном мире? Что вообще такое, это метапрограммирование? Вы уже
знаете все ответы, просто не осознаете их? Чтобы открыть скрытое хранилище божественных
знаний, давайте рассмотрим приземленную задачу простого доступа к базе данных из кода. 
Мы все когда то этим занимались. Написание SQL запросов по всему коду для изменения
данных в таблицах довольно скоро превращается в повторяющийся ад. Даже с новым C# 3.0 
LINQ - это огромная боль. Написание полного SQL-запроса (хотя и с хорошим встроенным
синтаксисом) для получения чьего-либо имени или изменения чьего-либо  адреса - это
не совсем удобная идея для программиста. Что мы делаем, чтобы решить эти проблемы? 
Вводим слои доступа к данным.
</p>

<p>Идея достаточно проста. Вы абстрагируете доступ к базе данных (по крайней мере,
тривиальные запросы), создавая набор классов, которые отражают таблицы в базе данных
и используют методы доступа доступа(accessor) для выполнения реальных запросов.
Это чрезвычайно упрощает разработку, вместо написания SQL-запросов мы делаем простые
вызовы методов (или присваиваем свойства, в зависимости от выбранного вами языка). 
Любой, кто когда-либо использовал даже самые простые слои доступа к базам данных,
знает, сколько времени это может сэкономить. Конечно, любой, кто когда-либо писал,
знает, сколько времени он может убить: написание набора классов, которые отражают
таблицы и конвертируют методы доступа(accessor) в SQL-запросы, занимает значительный
кусок времени. Это кажется особенно глупым, поскольку большая часть работы выполняется
в ручную: как только вы определитесь с дизайном и разработаете шаблон для вашего
типичного класса доступа к данным, вам не нужно будет думать. Вы просто пишете код на
основе одного и того же шаблона снова и снова, снова и снова. Многи люди поняли,
что есть лучший способ - есть множество инструментов, которые подключаются к базе
данных, захватывают схему, и пишут код для вас на основе предопределенного(или 
пользовательского) шаблона.
</p>

<p>Любой, кто когда либо пользовался таким инструментом, знает, что это может быть
удивительная экономия времени. В несколько кликов вы подключаете инструмент к 
базе данных, заставляете его генерировать исходный код слоя доступа к данным,
добавляете файлы в свой проект и вуаля - десять минут работы делают работу лучше,
чем сотни человеко-часов, которые требовались ранее. Что произойдет, если схема
вашей базы данных изменится? Ну вам просто нужно пройти через этот короткий процесс
еще раз. Конечно, некотоыре из лучших инструментов позволяют вам автоматизировать это
- вы просто добавляете их как часть вашего шага сборки, и каждый раз, когда вы
компилируете свой проект, все делается автоматически. Это же прекрасно!
Теперь вообще почти ничего не нужно делать. Если схема когда либо изменит ваш код
слоя доступа к данным автоматически обновляется во время компиляции и любой
устаревший доступ в вашем коде приведет к ошибкам компиляции!</p>

<p>Слои доступа к данным - это один хороший пример, но есть и много других. От
стандартного кода GUI, до веб кода, заглушек COM и CORBA,  MFC и ATL, - существует
множество примеров, когда один и тот же код пишется снова и снова. Поскольку
написание этого кода является задачей, которую можно полностью автоматизировать, 
а время программиста на много дороже, чем время процессора, было создано множество
инструментов, которые автоматические генерируют этот шаблонный код. Собственно говоря,
что это за инструменты? Ну, это программы, которые пишут программы. Они выполняют
простую задачу, имеющую загадочное название - метапрограммирование. Вот и все,
что нужно сделать.
</p>

<p>Мы могли бы создать и использовать такие инструменты в милионах сценариев, но чаще всего мы этого
не делаем. Это сводиться к подсознательному расчету - стоит ли мне создавать отдельный проект,
писать целый инструмент для создания чего-то, а затем использовать его, если мне нужно только написать
эти очень похожие куски примерно семь раз? Кончено же, НЕТ! Слои доступа к данным и заглушки COM пишутся
сотни и тысячи раз. Вот почему для них существуют инструменты. Для подобных фрагментов кода, которые 
повторяются только несколько раз или даже несколько десятков раз, написание инструментов генерации
кода даже не рассматривается. Трудность создания такого инструмента чаще всего намного перевешивает
пользу от его использования. Если бы только создание таких инструментов было намного проще, мы могли
бы использовать их чаще и, возможно, сэкономить много часов нашего времени. Давайте посмотрим,
сможем ли мы сделать это разумным образом.
</p>

<p>Удивительно, но препроцессор Си приходит на помощь. Мы все использовали его в Си и Си++.
Иногда нам всем хотелось бы, чтобы на и Java был такой же. Мы используем его для выполнения
простых инструкций во время компиляции, чтобы внести небольшие изменения в наш код(например,
выборочное удаление операторов отладки). Давайте посмотрим на быстрый пример:
</p>

<pre>#define triple(X)    X + X + X
</pre>

<p>Что делает эта строка? Эта простая инструкция, написанная на языке препроцессора, которая
инструктирует его заменить все экземпляры <em>triple(X)</em> на <em>X + X + X</em>. Например,
все экземпляры '<em>triple(5)</em>' будут заменены на '<em>5 + 5 + 5</em>' и полученный код
будет скомпилирован компилятором Си. Здесь, мы действительно делаем очень примитивную версию 
генереации кода. Если бы только препроцессор Си был немного более мощным и включал бы способы
подключения к базам данных и несколько более простых конструкций, мы могли бы использовать его
для разработки нашего слоя доступа к данным прямо из нашей программы! Рассмотрим следующий 
пример, в котором используется воображаемое расширение препроцессора Си:</p>

<pre>#get-db-schema("127.0.0.1, un, pwd");
#iterate-through-tables
#for-each-table
    class #table-name
    {
    };
#end-for-each
</pre>

<p>Мы только что подключились к схеме базы данных, перебрали все таблицы и создали
пустой класс для каждой из них. И все это в паре строк прямо в нашем исходном коде!
Теперь каждый раз, когда мы перекомпилируем файл, в котором появляется приведенный
выше код, мы получим новый набор классов, которые автоматически обновляются на
основе схемы БД. При небольшом воображении вы можете увидеть, как могли бы построить
полный слой доступа к данным прямо из нашей программы, без использования каких-либо
внешних инструментов! Конечно, он имеет определенный недостаток (помимо того, что
такой продвинутой версии препроцессора Си не существует) - нам пришлось бы выучить
совершенно новый "язык времени компиляции", чтобы выполнить такую работу. Для создания
сложного кода этот язык тоже должен быть очень сложным, он должен поддерживать множество
библиотек и языковых конструкций. Например, если бы наш сгенерированный код зависел бы
от какого-то файла, расположенного на каком-то ftp серевер, препроцессор должен был бы
иметь возможность подключиться к  ftp. Позорно создавать и изучать новый язык только для
того, чтобы сделать это. Тем более, что там уже есть так много хороших языков. Конечно,
если мы добавим немного смекалки, мы легко сможем избежать этой ловушки.
</p>

<p>Почему бы не заменить язык препроцессора на сам Си/Си++? Мы будем обладать всей мощью
языка во время компиляции, и нам нужно будет выучить несколько простых директив,
чтобы различать время компиляции и код времени выполнения!</p>

<pre>&lt;%
    cout &lt;&lt; "Enter a number: ";
    cin &gt;&gt; n;
%&gt;
for(int i = 0; i &lt; &lt;%= n %&gt;; i++)
{
    cout &lt;&lt; "hello" &lt;&lt; endl;
}
</pre>

<p>Можете ли вы увидеть, что здесь происходит? Все что находиться между тегами &lt;% и %&gt;
запускается при компиляции программы. Все что находится за пределами этих тегов, является
обычным кодом. В приведенном выше примере вы начнете компилировать свою программу в
среде разработки. Код между тегами будет скомпилирован и затем запущен. Вы получите
приглашение ввести номер. Вы введете номер(например один) и он будет помещен в цикл for.
Затем цикл for будет скомпилирован как обычно, и вы сможете его выполнить. Например,
если бы вы ввели 5 во время компиляции вашей программы, полученный код выглядел бы
следующим образом:</p>

<pre>for(int i = 0; i &lt; 5; i++)
{
    cout &lt;&lt; "hello" &lt;&lt; endl;
}
</pre>

<p>Просто и эффективно. Нет необходимости в специальном языке препроцессора. Мы получаем
полную мощность нашего основного языка (в данном случае C/C++) во время компиляции. Мы
можем легко подключиться к базе данных и сгенерировать исходный код нашего слоя доступа
к данным во время компиляции таким же образом как JSP или ASP генерируют HTML! Создание
таких инструментов также было бы чрезвычайно быстрым и простым. Нам не нужно беспокоиться
о том, стоит ли писать такие инструменты, потому что написание их было бы очень быстрым - 
мы могли бы сэкономить огромное количество времени, создавая простые фрагменты кода,
которые выполняют за нас обычную генерацию кода!
</p>

				<h2><a id="part_8">Привет, Lisp!</a></h2>
				<p class="first">Все, что мы узнали о Лиспе до сих пор,
можно обобщить одним утверждением: Lisp это исполняемый XML с блее дружественным синтаксисом.
Мы не сказали ни слова о том, как на самом деле работает Лисп. Пришло время заполнить этот
пробел<sup><a href="#note-blaise">2</a></sup>.
</p>

<p>Lisp имеет ряд встроенных типов данных. Например, целые(Integers) и строки(string)
мало чем отличающиеся от того, к чему вы привыкли. Значение <em>71</em> или <em>"hello"</em> 
примерно такое же, как в Си++ или Java. Для нас более интересны символы(<em>symbols</em>),
списки(<em>lists</em>) и функции(<em>functions</em>). Я проведу оставшуюся часть этого раздела,
описывая эти типы данных, а также то, как среда Лисп компилирует и выполняет исходный код,
который вы вводите в неё (это называется оценкой(<em>evaluation</em>) на языке Лисп(прим. переводчика:
я все же обычно перевожу это как выполнение, так как мне это более привычно). Прохождение этого
раздела целиком важно для понимания истинного потенциала метапрограммирования Лисп.,
единства кода и данных, а также понимания предметно(доменно)-ориентированных языков(domain
specific language). Не думайте об этом разделе как о рутинной работе, хотя я постараюсь сделать
его веселым и доступным. Надеюсь, вы сможете подобрать несколько интересных идей по пути. Ну что ж,
давайте начнем с символов Лисп.
</p>

<p>Символ в Лиспе примерно эквивалентен понятию идентификатора в Си++ или Java.
Это имя, которое вы можете использовать для доступа к переменной (например 
<em>currentTime</em>, <em>arrayCount</em>, <em>n</em>, и т.д.). Разница в том,
что символ в Лиспе намного более либерален, чем его альтернатива в основном
направлении программирования. В Си++ или Java вы ограничены буквенно-цифровыми
знаками и знаком подчеркивания. В Лиспе, таких ограничений нет. Например: <em>+</em>
является допустимым символом. То есть <em>-</em>, <em>=</em>, <em>hello-world</em>, 
<em>hello+world</em>, <em>*</em>, и т.д. (вы можете найти точное определение
действительных символов в Лиспе в интернете). Вы можете назначить этим символам
любой тип данных, который вам нравиться. Давайте проигнориуем синтаксис Лисп и
пока воспользуемся псевдокодом. Предположим, что функция set присваивает символу
какое-то значение(как это делает <em>=</em> в Java или C++). Ниже приведены все
действительные примеры:
</p>

<pre>set(test, 5)       // символ 'test' будет равен целому 5
set(=, 5)               // символ '=' будет равен целому 5
set(test, "hello")      // символ 'test' будет равен строке "hello"
set(test, =)            // в этой точке символ '=' равен 5
                        // поэтому символ 'test' будет равен 5
set(*, "hello")         // символ '*' будет равен строке "hello"
</pre>

<p>На данный момент это попахивает не очень хорошо. Если мы можем присвоить строки и
числа таким символам как <em>*</em>, как тогда Лисп выполнить умножение? В конце концов,
<em>*</em> означает умножение, верно? Ответ довольно прост. Функции в Лиспе не особенные.
Существует тип данных фунция(function), такой же как целое(integer) и строка(string), значения
этих типов вы присваиваете символам. Функция умножения встроена в Лисп и присваивается символу <em>*</em>.
Вы можете переназначить другое значение <em>*</em> и потеряете функцию умножения. Или вы можете
сохранить значение функции в другой переменной. Опять же используя псевдокод:
(прим.переводчика: все вышесказанное относится к диалекту лиспа: Scheme, современный ansi common
lisp имеет два пространства имен, одно для символов функций и второе для символов переменных,
там тоже можно сделать нечто подобное, но только более сложным образом)
</p>

<pre>*(3, 4)                 // multiplies 3 by 4, resulting in 12
set(temp, *)            // symbol '*' is equal to the multiply function
                        // so temp will equal to the multiply function
set(*, 3)               // sets symbol '*' to equal to 3
*(3, 4)                 // error, symbol '*' no longer equals to a function
                        // it's equal to 3
temp(3, 4)              // temp equals to a multiply function
                        // so Lisp multiplies 3 by 4 resulting in 12
set(*, temp)            // symbol '*' equals multiply function again
*(3, 4)                 // multiplies 3 by 4, resulting in 12
</pre>

<p>Вы можете даже делать дурацкие вещи, такие как переназначение плюса на минус:
</p>

<pre>set(+, -)               // the value of '-' is a built in minus function
                        // so now symbol '+' equals to a minus function
+(5, 4)                 // since symbol '+' is equal to the minus function
                        // this results in 1
</pre>

<p>В этих примерах я довольно свободно использовал функции, но пока не описывал их.
Функция в Лиспе это просто тип данных, такой как целое число, строка или символ.
Функция не имеет такого понятия как имя, подобное в Си++ или Java. Вместо этого,
она стоит сама по себе. Фактически, это указатель на блок кода вместе с некоторой
информацией(например, рядом параметров, которые она принимает). Только вы даете
функции имя, назначая(присваивая) ее символу, точно так же, как вы присваиваете
целое число или строку. Вы можете создать функцию используя встроенную функцию
для создания функций, присвоенную символу 'fn'(прим. перводчика: вообщето это lambda). 
Использя псевдо-код:</p>

<pre>fn [a]
{
    return *(a, 2);
}
</pre>

<p>Эта конструкция возвращает функцию, котора принимает единственный параметр 
именумый <em>'a'</em> и удваивает его. Обратите внимание, что у функции нет
имени, но вы можте присвоить её символу:
</p>

<pre>set(times-two, fn [a] { return *(a, 2); })
</pre>

<p>Теперь мы можем вызвать эту функцию:
</p>

<pre>times-two(5)             // returns 10
</pre>

<p>Теперь, когда мы рассмотрели символы и функции, как на счет списков?
Ну, вы уже много знаете о них. Списки это просто фрагменты  XML записанные
в форме s-выражений. Список задается круглыми скобками и содержит типы данных
Лисп (включая и другие списки), разделенные пробелами. Например (это
настоящий Лисп, обратите внимание, что теперь мы используем точку с запятой,
для комментариев):
</p>

<pre>()                      ; пустой списокan empty list
(1)                     ; список из одного элемента, 1
(1 "test")              ; a list with two elements
                        ; an integer 1 and a string "test"
(test "hello")          ; a list with two elements
                        ; a symbol test and a string "hello"
(test (1 2) "hello")    ; список с тремя элементами, символа test
                        ; списка двух целых 1 и 2
                        ; и строки "hello"
</pre>

<p>Когда система Лисп сталкивается со списками в исходном коде, она действует
точно так же, как  Ant, когда он сталкивается с XML - она пытается исполнить их. 
На самом деле исходный код Лисп и задается только с помощью списков, точно
также как исходный код Ant задается только с помощью использования XML. Лисп
выполняет списки следующим образом. Первый элемент списка обрабатывается как
имя функции. Остальные элементы рассматриваются как параметры функции. Если один
из параметров является другим списком, то он выполняется по тем же принципам,
и результат передается в качестве параметра исходной функции. Вот и все.
Теперь мы можем писать настоящий код:
</p>

<pre>(* 3 4)                 ; equivalent to pseudo-code *(3, 4).
                        ; Symbol '*' is a function
                        ; 3 and 4 are its parameters.
                        ; Returns 12.
(times-two 5)           ; returns 10
(3 4)                   ; error: 3 is not a function
(times-two)              ; error, times-two expects one parameter
(times-two 3 4)          ; error, times-two expects one parameter
(set + -)               ; sets symbol '+' to be equal to whatever symbol '-'
                        ; equals to, which is a minus function
(+ 5 4)                 ; returns 1 since symbol '+' is now equal
                        ; to the minus function
(* 3 (* 2 2))           ; multiplies 3 by the second parameter
                        ; (which is a function call that returns 4).
                        ; Returns 12.
</pre>

<p>Обратите внимание, что до сих пор каждый указанный нами список обрабатывался
системой Лисп как код. Но как же мы можем рассматривать список как данные? Опять же,
представьте себе задачу Ant, которая принимает XML в качестве одного из своих
параметров. В лиспе мы делаем с помощью оператора quote или сокращенно
<em>'</em>, например так:</p>

<pre>(set test '(1 2))         ; test is equal to a list of two integers, 1 and 2
(set test (1 2))           ; error, 1 is not a function
(set test '(* 3 4))        ; sets test to a list of three elements,
(set test (quote (* 3 4))) ; a symbol *, an integer 3, and an integer 4, длинная запись с оператором quote
</pre>

<p>Мы можем использовать встроенную функцию <em>head</em> для возврата первого
элемента списка, и встроенную функцию <em>tail</em> для возврата последнего
элемента списка:
</p>

<pre>(head '(* 3 4))         ; returns a symbol '*'
(tail '(* 3 4))         ; returns a list (3 4)
(head (tail '( * 3 4))) ; (tail '(* 3 4)) returns a list (3 4)
                        ; and (head '(3 4)) returns 3.
(head test)             ; test was set to a list in previous example
                        ; returns a symbol '*'
</pre>

<p>Вы можете думать о встроенных функциях Лисп, как вы думаете о задачах в Ant. 
Разница в том, что нам не нужно расширять Лисп на другом языке (хотя и это возмжно),
мы можем расширить его на самом Лиспе, как это была в примере с <em>times-two</em>.
Лисп поставляется с очень компактным набором встроенных функций - необходимым минимумом.
Остальная часть языка реализована как стандартная библиотека на самом Лиспе.
</p>

				<h2><a id="part_9">Макросы Лисп</a></h2>
				<p class="first">До сих пор мы рассматривали метапрограммирование
с точки зрения простого шаблонизатора(templating engine), похожего на JSP. Мы сделали
генерацию кода, используя простые манипуляции со строками. Как правило, именно так
большинство инструментов генерации кода выполняют эту задачу. Но мы можем сделать
намного лучше. Чтобы встать на правильный путь, давайте начнем с вопроса. Как написать
инструмент, который автоматически генерирует сценарии сборки Ant, просматривая
исходные файлы в структуре каталогов?
</p>

<p>Мы могли бы пойти простым путем и сгенерировать Ant XML, манипулируя строками.
Конечно, более абстрактный, выразительный и расширяемый способ - работать с 
библиотеками обработки  XML для генерации узлов XML непосредственно в памяти.
Затем узлы могут быть автоматически сериализованы в строки. Кроме того, наш инструмент
сможет анализировать и преобразовывать существующие сценарии сборки Ant загружая их
и напрямую работая с узлами XML. Мы бы абстрагировались от строк и имели дело с 
концепциями более высокого уровня, которые позволяют выполнить работу быстрее
и проще.
</p>

<p>Конечно, мы могли бы написать задачи Ant, которые позволяют иметь
дело с преобразованиями XML, и написать наш инструмент генерации на
самом Ant. Или мы могли бы просто использовать Лисп. Как мы видели 
ранее, список представляет собой встроенную структуру данных Лисп
и Лисп имеет ряд средств для быстрой и эффективной обработки списков
(простейшие из них это <em>head</em> и <em>tail</em>). Кроме того,
в Лиспе нет семантических ограничений - вы может иметь свой код 
(и данные) любой структуры, по вашему желанию.
</p>

<p>
Метапрограммирование на Лиспе осуществляется с помощью конструкции, называемой "macro". 
Давайте попробуем разработать набор макросов, которые преобразовывают данные, например
список дел (удивлены?), в язык для работы со списками дел.
</p>

<p>Давайте вспомним наш пример списка дел. Его XML выглядит так:</p>

<pre>&lt;todo name="housework"&gt;
    &lt;item priority="high"&gt;Clean the house.&lt;/item&gt;
    &lt;item priority="medium"&gt;Wash the dishes.&lt;/item&gt;
    &lt;item priority="medium"&gt;Buy more soap.&lt;/item&gt;
&lt;/todo&gt;
</pre>

<p>Соответствующая версия s-выражения выглядит так:</p>

<pre>(todo "housework"
    (item (priority high) "Clean the house.")
    (item (priority medium) "Wash the dishes.")
    (item (priority medium) "Buy more soap."))
</pre>

<p>Предположим, что мы пишем приложение для управления делами(to-do manager).
Мы сохраним сериализацию наших дел в виде набора файлов и когда программа
запускается, мы хотим прочитать их и отобразить их пользователю. Как бы мы
сделали это с XML и другими языками (скажем, Java)? Мы бы проанализировали
наши XML файлы со списками дел используя какой-то XML парсер(анализатор), 
написали бы код, который обходит XML дерево и конвертирует его в структуру
данных Java (потому что, обработка DOM на Java это кость в горле), а затем
использовали бы эту структуру данных для отображения данных. Теперь, как бы
мы сделали тоже самое в Лиспе?
</p>

<p>
Если бы мы приняли тот же подход, мы бы анализировали файлы используя библиотеки
Лисп, отвечающие за синтаксический анализ XML. Затем XML будет представлен нам
как список Лисп (как s-выражение) и мы пройдемся по списку и представим соответствующие
данные пользователю. Конечно, если бы мы использовали Лисп, было бы целесообразно
хранить данные напрямую в виде s-выражений, поскольку нет смысла делать преобразования
в XML. Нам не понадобятся специальные библиотеки синтаксического анализа, поскольку данные,
сохраняемые в виде набора s-выражений, являются допустимыми для Лиспа и мы могли бы использовать
компилятор Лиспа(прим. переводчика: обычный читатель лисп выражений - read, это еще не компилятор лиспа)
для их анализа и сохранения в памяти в виде Лисп списка. Обратите внимание, что компилятор
Лиспа(очень похожий на компилятор .NET) доступен для Лисп программы во время выполнения.
</p>

<p>
Но мы можем сделать лучше! Вместо написания кода, для обхода s-выражений,
в которых хранятся наши данные, мы могли бы написать макрос, котоырй позволит
нам обрабатывать данные как код! Как работают макросы? По правде, довольно просто.
Напомним, что функция лисп вызывается так:
</p>

<pre>(function-name arg1 arg2 arg3)
</pre>

<p>
Где каждый аргумент является допустимым выражением Лисп, которое вычисляется
и передается фунции. Например, если мы заменим  <em>arg1</em> выше на <em>(+ 4 5)</em>, 
оно будет вычислено и  <em>9</em>  будет передано функции. Макрос работает также как
и функция, за исключением того, что его аргументы не вычисляются.
</p>

<pre>(macro-name (+ 4 5))
</pre>

<p>В этом случае (+ 4 5) не вычисляется и передается макросу в виде списка. Макрос может свободно
делать с этим списком, все что ему нравится, включая и его вычисление. Возвращаемое макросом значение -
это список Лисп, который рассматривается как код. Исходное место с макросом, заменяется этим кодом.
Например, мы могли бы определить макрос plus, который принимает два аргумента и добавляет код,
который их складывает.
</p>

<p>
Какое это отношение имеет к метапрограммированию и нашей проблеме со списком дел?
Ну, во первых, макросы это маленькие кусочки кода, которые генерируют код, используя
абстракцию списка. Кроме того, мы могли бы создать макросы с именем <em>to-do</em> и
<em>item</em>, которые заменяют наши данные любым кодом, который нам нравиться, например
который отображает элемент пользователю.
</p>

<p>
Какие преимущества предлагает этот подход? Нам не нужно проходить по списку.
Компилятор сделает это за нас и вызовет соответствующие макросы.  Всё, что
нам нужно сделать, это создать макросы, которые преобразуют наши данные в
соответствующий код!
</p>

<p>Например, макрос, похожий на наш Си макрос <em>triple</em> , который мы
продемонстрировали ранее, выглядит так:</p>

<pre>(defmacro triple (x)
    '(+ ~x ~x ~x))
</pre>

<p>Знак цитирования(quote) препятствует вычислению списка, в то время как тильда его
разрешает. Теперь каждый раз, когда встретиться <em>triple</em> в Лисп коде:
</p>

<pre>(triple 4)
</pre>

<p>
оно заменится следующим кодом:
</p>

<pre>(+ 4 4 4)
</pre>

<p>
Мы можем создать макрос для наших элементов(items) списка дел, который будет 
вызываться компилятором Лиспа и преобразовывать список дел в код. Теперь наш
список дел будет рассматриваться как код и будет выполнен. Предположим, что
все что мы хотим, это распечатать его в стандартный вывод, чтобы пользователь
мог его прочитать:
</p>

<pre>(defmacro item (priority note)
    '(block
         (print stdout tab "Priority: "
             ~(head (tail priority)) endl)
         (print stdout tab "Note: " ~note endl endl)))
</pre>

<p>
Мы только что создали очень маленький и ограниченный язык для управления
списком дел, встроенный в Лисп. Такие языки очень специфичны для конкретной
проблемной области и часто называются предметно(доменно) ориентированными
языками или <em>DSL</em>.
</p>

				<h2><a id="part_10">Предметно-Ориентированные Языки(Domain Specific Languages)</a></h2>
				<p class="first">В этой статье мы уже сталкивались с двумя предметно
ориентированными языками: Ant(специфичным для работы с построением проектов) и нашим безымянным
мини-языком для работы со списком дел. Разница в том, что Ant был написан с нуля с использованием XML,
синтаксического анализатора XML, и Java, в то время как наш язык встроен в Лисп и легко создается
в течении нескольких минут.
</p>

<p>
Мы уже обсуждали преимущества DSLs, главным образом, почему Ant использует XML, 
а не исходный код Java. Лисп позволяет нам создавать столько DSLs, сколько нам
нужно для нашей проблемы. Мы можем создавать доменно ориентированные языки для
создания веб-приложений, писать многопользовательские игры, заниматься торговлей
с фиксированным доходом, решать проблему свертывания белка, заниматься транзакциями
и т.д. Мы можем наложить эти языки друг на друга и создать язык для написания
веб-торговых приложений, используя преимущества нашего языка веб-приложений и
языка торговли облигациями. Каждый день мы пожинали бы плоды этого подхода,
также как мы пожинаем плоды создания Ant.
</p>

<p>
Использование DSLs для решения проблем приводит к гораздо более компактным,
сопровождаемым и гибким программам. В некотором смысле мы создаем их в Java
создавая классы, которые помогают нам решить эту проблему. Разница в том,
что Лисп позволяет вывести эту абстракцию на новый уровень: мы не ограничены
синтаксическим анализатором Java. Подумайте о написании сценариев сборки на
самом Java используя некоторую вспомогательную библиотеку. Сравните это
с использованием Ant.
Теперь примените это же сравнение к каждой отдельной проблеме, над которой
вы когда-либо работали, и вы начнете видеть небольшую долю преимуществ, 
предлагаемых Лиспом.
</p>

				<h2><a id="part_11">Что дальше?</a></h2>
				<p class="first">
Обучение Лиспу - это тяжелая битва. Несмотря на то, что в терминах компьютерных наук
Лисп - это древний язык, мало кто на сегодняшний день понял, как преподавать его на
хорошем уровне, чтобы сделать его доступным. Несмотря на огромные усилия многих
сторонников Лиспа, изучение Лиспа на сегодня, все еще очень трудно. Хорошая новость
заключается в том, что это не останется таковым навсегда, поскольку количество ресурсов,
связанных с Лисп, быстро растет. Время на стороне Лиспа.
</p>

<p>
Лисп это способ избежать посредственности и опередить стаю. Изучение Лиспа означает,
что вы можете получить лучшую работу сегодня, потому что вы можете произвести впечатление
на любого достаточно умного интервьюера свежим пониманием большинства аспектов разработки
программного обеспечения. Это также означает, что вас, скорее всего, уволят завтра, потому
что все устали от того, что вы постоянно упоминаете, насколько лучше могла бы работать
компания, если бы ее программное обеспечние было написано на Лиспе. Стоит ли это таких
усилий? Все, кто когда-либо учился программировать на Лиспе, говорят "ДА". Выбор, конечно
остается за вами.
</p>

				<h2><a id="part_12">Комментарии?</a></h2>
				<p class="first">Вот как то так. И этого достаточно. Я писал эту
статью в течении нескольких месяцев. Если вы находите её интересной, у вас есть какие-либо вопросы,
комментарии или предложения, пожалуйста напишите мне по адресук 
<a href="mailto:coffeemug@gmail.com">coffeemug@gmail.com</a>.
Я буду рад услышать ваши отзывы.</p>

				<div id="footnotes">

<p><sup><a id="note-james">1</a></sup>Я никогда не встречался с Джеймсом, и он не знает о
моем существовании. Эта история полностью вымышлена и основана на нескольких
публикациях об истории Ant, которые я нашел в интернете.</p>

<p><sup><a id="note-blaise">2</a></sup>Lisp имеет много различных диалектов
(наиболее популярными являются Common Lisp и Scheme). Каждый диалект имеет дело
с запутанными деталями по разному, но разделяет один и тот же набор основных
принципов. Поскольку цель этой статьи - дать вам понимание принципов Лисп, я буду
использовать Blaise для примеров (который на момент написания этой статьи являлся
vaporware). С некоторыми незначительными изменениями эти примеры могут быть переведены
на другие диалекты Лиспа.</p>

				</div>
			</div>
		</div>
		<div id="page-extra-4"><div id="page-extra-5"><div id="page-extra-6">&nbsp;</div></div></div>
		</div></div></div>
		<div id="footer">

<p>Все, что находится на этом сайте, является общественным достоянием, если не указано
иное.<br>
Мои контакты для вопросов и комментариев, через 
<a href="mailto:coffeemug@gmail.com">coffeemug@gmail.com</a>.</p>

			<img src="../images/valid-xhtml11.png" alt="Valid XHTML 1.1">
			<img src="../images/valid-css.png" alt="Valid CSS">
			<img src="../images/valid-rss.png" alt="Valid RSS">
		</div>
		</div>

</body></html>
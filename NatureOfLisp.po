#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/NatureOfLisp.htm
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-03-16 11:38+0300\n"
"PO-Revision-Date: 2020-03-19 11:17+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/NatureOfLisp.htm:12
msgid ""
"<!--?xml version=\"1.0\" encoding=\"UTF-8\"?-->\n"
"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/"
"xhtml11/DTD/xhtml11.dtd\">\n"
"<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"><head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n"
"\t\t<title>defmacro - The Nature of Lisp</title>\n"
"\t\t<meta name=\"description\" content=\"An article about Lisp programming "
"language.\">\n"
"\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"defmacro%20-%20The"
"%20Nature%20of%20Lisp_files/main.css\" media=\"screen\">\n"
"\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"defmacro%20-%20The"
"%20Nature%20of%20Lisp_files/articles.css\" media=\"screen\">\n"
"\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"defmacro%20-%20The"
"%20Nature%20of%20Lisp_files/print.css\" media=\"print\">\n"
"\t\t<link rel=\"alternate\" type=\"application/rss+xml\" title=\"defmacro.org"
"\" href=\"http://www.defmacro.org/rss/news.xml\">\n"
"\t\t<link rel=\"home\" href=\"http://www.defmacro.org/index.html\">"
msgstr ""

#: in/NatureOfLisp.htm:25
msgid ""
"\t\t<style type=\"text/css\">\n"
"\t\t\t.list {\n"
"\t\t\t\tfont-weight: bold;\n"
"\t\t\t}\n"
"\t\t\t.inner-list {\n"
"\t\t\t\tcolor: red;\n"
"\t\t\t}\n"
"\t\t\t.inner-inner-list {\n"
"\t\t\t\tcolor: blue;\n"
"\t\t\t\tfont-weight: bold;\n"
"\t\t\t}\n"
"\t\t</style>"
msgstr ""

#: in/NatureOfLisp.htm:49
msgid ""
"\t</head><style type=\"text/css\" id=\"block-image-video\"> svg {visibility: "
"hidden !important; opacity: 0 !important}  img {visibility: hidden !"
"important; opacity: 0 !important}  video {visibility: hidden !important; "
"opacity: 0 !important}  canvas {visibility: hidden !important; opacity: 0 !"
"important}  iframe [type=\"application/x-shockwave-flash\"] {visibility: "
"hidden !important; opacity: 0 !important}  .hide {visibility: hidden !"
"important; opacity: 0 !important} </style>\n"
"\t<body>\n"
"\t\t<div id=\"wrapper\"><div id=\"wrapper1\"><div id=\"wrapper2\"><div id="
"\"wrapper3\">\n"
"\t\t\t<div id=\"page-extra-1\"><div id=\"page-extra-2\"><div id=\"page-"
"extra-3\">&nbsp;</div></div></div>\n"
"\t\t\t<div id=\"wrapper4\">\n"
"\t\t\t<div id=\"header\">\n"
"\t\t\t\t<div id=\"header-extra-1\">\n"
"\t\t\t\t<div id=\"header-extra-2\">\n"
"\t\t\t\t<div id=\"header-extra-3\">\n"
"\t\t\t\t<div id=\"header-extra-4\">\n"
"\t\t\t\t\t<div id=\"header-extra-5\">\n"
"\t\t\t\t\t  <a class=\"home\" href=\"http://www.defmacro.org/\">Home - "
"defmacro.org</a>\n"
"\t\t\t\t\t  <span id=\"title\">Made with alien technology.</span>\n"
"\t\t\t\t\t\t<div id=\"syndication\"><a href=\"http://www.defmacro.org/rss/"
"news.xml\" title=\"RSS Feed\"><img src=\"../images/xml.png\" alt=\"RSS Feed"
"\"></a></div>\n"
"\t\t\t\t\t</div>\n"
"\t\t\t\t</div>\n"
"\t\t\t\t</div>\n"
"\t\t\t\t</div>\n"
"\t\t\t\t</div>\n"
"\t\t\t</div>\n"
"\t\t\t<div id=\"content\">\n"
"\t\t\t\t<h1>The Nature of Lisp</h1>\n"
"\t\t\t\t<div class=\"date\">Monday, May 8, 2006</div>"
msgstr ""
"\t</head><style type=\"text/css\" id=\"block-image-video\"> svg {visibility: "
"hidden !important; opacity: 0 !important}  img {visibility: hidden !"
"important; opacity: 0 !important}  video {visibility: hidden !important; "
"opacity: 0 !important}  canvas {visibility: hidden !important; opacity: 0 !"
"important}  iframe [type=\"application/x-shockwave-flash\"] {visibility: "
"hidden !important; opacity: 0 !important}  .hide {visibility: hidden !"
"important; opacity: 0 !important} </style>\n"
"\t<body>\n"
"\t\t<div id=\"wrapper\"><div id=\"wrapper1\"><div id=\"wrapper2\"><div id="
"\"wrapper3\">\n"
"\t\t\t<div id=\"page-extra-1\"><div id=\"page-extra-2\"><div id=\"page-"
"extra-3\">&nbsp;</div></div></div>\n"
"\t\t\t<div id=\"wrapper4\">\n"
"\t\t\t<div id=\"header\">\n"
"\t\t\t\t<div id=\"header-extra-1\">\n"
"\t\t\t\t<div id=\"header-extra-2\">\n"
"\t\t\t\t<div id=\"header-extra-3\">\n"
"\t\t\t\t<div id=\"header-extra-4\">\n"
"\t\t\t\t\t<div id=\"header-extra-5\">\n"
"\t\t\t\t\t  <a class=\"home\" href=\"http://www.defmacro.org/\">Home - "
"defmacro.org</a>\n"
"\t\t\t\t\t  <span id=\"title\">Made with alien technology.</span>\n"
"\t\t\t\t\t\t<div id=\"syndication\"><a href=\"http://www.defmacro.org/rss/"
"news.xml\" title=\"RSS Feed\"><img src=\"../images/xml.png\" alt=\"RSS Feed"
"\"></a></div>\n"
"\t\t\t\t\t</div>\n"
"\t\t\t\t</div>\n"
"\t\t\t\t</div>\n"
"\t\t\t\t</div>\n"
"\t\t\t\t</div>\n"
"\t\t\t</div>\n"
"\t\t\t<div id=\"content\">\n"
"\t\t\t\t<h1>Природа Лиспа (The Nature of Lisp)</h1>\n"
"\t\t\t\t<div class=\"date\">Monday, May 8, 2006</div>"

#: in/NatureOfLisp.htm:60
msgid ""
"\t\t\t\t<h2><a id=\"part_1\">Introduction</a></h2>\n"
"\t\t\t\t<p class=\"first\">When I first stumbled into Lisp advocacy on "
"various\n"
" corners of the web I was already an experienced programmer. At that\n"
"                point I had grokked what seemed at the time a wide range\n"
" of programming languages. I was proud to have the usual suspects (C++, \n"
"Java, C#,\n"
"                etc.) on my service record and was under impression that\n"
" I knew everything there is to know about programming languages. I \n"
"couldn't have\n"
"                possibly been more wrong.</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_1\">Введение</a></h2>\n"
"\t\t\t\t<p class=\"first\">Когда я столкнулся с пропагандой Лиспа в разных\n"
"уголках сети, я был уже опытным программистом. В тот момент я ухватился за "
"то, что в то время казалось\n"
"широким спектром языков программирования. Я гордился тем, что в моем "
"послужном списке значились (C++, \n"
"Java, C#, и иже с ними.), и у меня сложилось впечатление, что я знаю ВСЁ, "
"что нужно знать о языках\n"
"программирования. Как же я был тогда не прав.</p>"

#: in/NatureOfLisp.htm:70
msgid ""
"<p>My initial attempt to learn Lisp came to a crashing halt as soon \n"
"as I saw some sample code. I suppose the same thought ran through my \n"
"\t\t\t\tmind that ran through thousands of other minds who were ever in my \n"
"shoes: \"Why on Earth would anyone want to use a language with such \n"
"\t\t\t\thorrific syntax?!\" I couldn't be bothered to learn a language if "
"its\n"
" creators couldn't be bothered to give it a pleasant syntax. \n"
"\t\t\t\tAfter all, I was almost blinded by the infamous Lisp parentheses!</p>"
msgstr ""
"<p>Моя первая попытка изучить Лисп потерпела крах, как только я увидел "
"пример кода. Я полагаю, что\n"
"в моей голове возникла та же мысль, которая пронзила тысячи других людей, "
"которые когда либо были\n"
"в моем положении: \"С какой стати кто-то захочет использовать язык с таким "
"ужасным синтаксисом?!\".\n"
"Я не буду изучать язык, если его создатели не удосужились дать ему приятный "
"для пользователя синтаксис. \n"
"В конце концов, я был почти ослеплен печально известными скобками Лиспа!</p>"

#: in/NatureOfLisp.htm:91
msgid ""
"<p>The moment I regained my sight I communicated my frustrations to \n"
"some members of the Lisp sect. Almost immediately I was bombarded by \n"
"\t\t\t\ta standard set of responses: Lisp's parentheses are only a \n"
"superficial matter, Lisp has a huge benefit of code and data being \n"
"\t\t\t\texpressed in the same manner (which, obviously, is a huge \n"
"improvement over XML), Lisp has tremendously powerful metaprogramming \n"
"\t\t\t\tfacilities that allow programs to write code and modify "
"themselves, \n"
"Lisp allows for creation of mini-languages specific to the \n"
"\t\t\t\tproblem at hand, Lisp blurs the distinction between run time and \n"
"compile time, Lisp, Lisp, Lisp... The list was very impressive. \n"
"\t\t\t\tNeedless to say none of it made sense. Nobody could illustrate the \n"
"usefulness of these features with specific examples because these \n"
"\t\t\t\ttechniques are supposedly only useful in large software systems. \n"
"After many hours of debating that conventional programming languages \n"
"\t\t\t\tdo the job just fine, I gave up. I wasn't about to invest months \n"
"into learning a language with a terrible syntax in order to \n"
"\t\t\t\tunderstand obscure features that had no useful examples. My time "
"has\n"
" not yet come.</p>"
msgstr ""
"<p>В тот момент, когда я вновь обрел зрение, я сообщил о своих "
"разочарованиях некоторым членам\n"
"секты Лисп. Почти сразу же я был засыпан стандартным набором ответов: "
"круглые скобки Лиспа это\n"
"не существенный вопрос, Лисп имеет огромное преимущество перед другими "
"языками выражая данные\n"
"и код одинаковым способом. (что, очевидно, является огромным улучшением по "
"сравнению с XML), \n"
"Лисп имеет невероятно мощные средства метапрограммирования, которые "
"позволяют программам\n"
"писать код и изменять себя, Лисп позволяет создавать мини-языки, "
"узкоспецифичные для рассматриваемой\n"
"проблемы, Лисп стирает различия между временем выполенния и временем "
"компиляции, Лисп, Лисп, Лисп .....\n"
"Список был очень впечатляющим. Излишне говорить, что ничего из этого для "
"меня не имело смысла. \n"
"Никто не мог проилюстрировать полезность этих функций конкретными примерами, "
"потому что эти методы\n"
"предположительно полезны только в больших программных системах. \n"
"После многих часов дискуссий о том, что обычные языки программирования "
"отлично справляются со своими\n"
"задачами, я сдался. Я не собирался тратить месяцы на изучение языка с "
"ужасным синтаксисом, чтобы понять\n"
"неясные особенности, которые не имели полезных и ясных примеров. Мое время "
"еще не пришло!\n"
"</p>"

#: in/NatureOfLisp.htm:104
msgid ""
"<p>For many months the Lisp advocates pressed on. I was baffled. \n"
"Many extremely intelligent people I knew and had much respect for were \n"
"\t\t\t\tpraising Lisp with almost religious dedication. There had to be \n"
"something there, something I couldn't afford not to get my hands on! \n"
"\t\t\t\tEventually my thirst for knowledge won me over. I took the plunge, \n"
"bit the bullet, got my hands dirty, and began months of mind \n"
"\t\t\t\tbending exercises. It was a journey on an endless lake of \n"
"frustration. I turned my mind inside out, rinsed it, and put it back in \n"
"\t\t\t\tplace. I went through seven rings of hell and came back. And then "
"I \n"
"got it.</p>"
msgstr ""
"<p>В течении многих месяцев сторонники Лиспа продолжали свою коварную "
"агитацию. \n"
"Я был сбит с толку. Многие чрезвычайно умные люди, которых я знал и которых "
"очень уважал,\n"
"восхаляли ЛИСП, почти с религиозной преданностью. Там должно было быть что-"
"то, и я не мог\n"
"позволить себе упустить ЭТУ божественную тайну из своих рук! В конце концов "
"моя жажда знаний победила меня.\n"
"Я сделал решающий шаг, закусив удила, закатав рукава начал месяцами "
"выполнять упражнения\n"
"выворачивающие мне мозг. Это было путешествие по бесконечному озеру "
"разочарования.\n"
"Я вывернул свой разум наизнанку, промыл его и поставил на место. Я прошел "
"через семь\n"
"кругов ада и вернулся. И тогда я получил ЭТО!\n"
"</p>"

#: in/NatureOfLisp.htm:121
msgid ""
"<p>The enlightenment came instantaneously. One moment I understood \n"
"nothing, and the next moment everything clicked into place. I've \n"
"\t\t\t\tachieved nirvana. Dozens of times I heard Eric Raymond's statement \n"
"quoted by different people: \"Lisp is worth learning for the \n"
"\t\t\t\tprofound enlightenment experience you will have when you finally "
"get\n"
" it; that experience will make you a better programmer for the \n"
"\t\t\t\trest of your days, even if you never actually use Lisp itself a \n"
"lot.\" I never understood this statement. I never believed it could be \n"
"\t\t\t\ttrue. And finally, after all the pain, it made sense! There was "
"more\n"
" truth to it than I ever could have imagined. I've achieved an \n"
"\t\t\t\talmost divine state of mind, an instantaneous enlightenment \n"
"experience that turned my view of computer science on its head in less \n"
"than \n"
"\t\t\t\ta single second.</p>"
msgstr ""
"<p>Просветление пришло внезапно. В один момент я ничего не понимал, а в "
"следующий все встало на свои\n"
"места. Я достиг нирваны. Десятки раз я слышал слова Эрика Рэймонда, "
"цитируемые разными людьми: \"Лиспу\n"
"стоит учиться для обретения того глубокого просветления, которое вы получите "
"в конце обучения(возможно\n"
"получите); и этот опыт сделает вас лучшим программистом до конца ваших дней, "
"даже если вы на самом деле\n"
"никогда не воспользуетесь самим Лиспом.\" Я никогда не понимал этого "
"утверждения. Я никогда не верил, что\n"
"это может быть правдой. и наконец, после всей боли, оно обрело смысл! В нем "
"было больше правды, чем\n"
"я мог себе представить. Я достиг почти божественного состояния ума, "
"мгновенного опыта просветления,\n"
"который перевернул мой взгляд на информатику с ног на голову менее чем за "
"одну секунду.\n"
"</p>"

#: in/NatureOfLisp.htm:134
msgid ""
"<p>That very second I became a member of the Lisp cult. I felt \n"
"something a ninjitsu master must feel: I had to spread my newfound \n"
"\t\t\t\tknowledge to at least ten lost souls in the course of my lifetime. "
"I\n"
" took the usual path. I was rehashing the same arguments that \n"
"\t\t\t\twere given to me for years (only now they actually made sense!), \n"
"hoping to convert unsuspecting bystanders. It didn't work. My \n"
"\t\t\t\tpersistence sparked a few people's interest but their curiosity \n"
"dwindled at the mere sight of sample Lisp code. Perhaps years of \n"
"\t\t\t\tadvocacy would forge a few new Lispers, but I wasn't satisfied. \n"
"There had to be a better way.</p>"
msgstr ""
"<p>В туже секунду я стал членом культа Лиспа. Я чувствовал что-то, что "
"должен чувствовать мастер\n"
"ниндзюцу: Я должен был распространить свои обретенные знания по крайней мере "
"на десять потерянных\n"
"душ в течение моей жизни. Вначале я выбрал обычный путь. Я перефразировал те "
"же аргументы, которыми\n"
"меня пичкали годами (только теперь они действительно имели для меня "
"смысл!), \n"
"надеясь обратить в свою веру, ни в чем не подозревающих прохожих, но это не "
"сработало! Моя настойчивость\n"
"вызвала интерес нескольких людей, но их любопытство угасло, при виде "
"простого примера кода на Лиспе.\n"
"Возможно, годы пропаганды выковали бы несколько новых Лисперов, но я не был "
"бы этим удовлетворен. \n"
"Должен был быть лучший способ.\n"
"</p>"

#: in/NatureOfLisp.htm:153
msgid ""
"<p>I gave the matter careful thought. Is there something inherently \n"
"hard about Lisp that prevents very intelligent, experienced \n"
"\t\t\t\tprogrammers from understanding it? No, there isn't. After all, I "
"got\n"
" it, and if I can do it, anybody can. Then what is it that makes \n"
"\t\t\t\tLisp so hard to understand? The answer, as such things usually do, \n"
"came unexpectedly. Of course! Teaching anybody anything involves \n"
"\t\t\t\tbuilding advanced concepts on top of concepts they already \n"
"understand! If the process is made interesting and the matter is \n"
"explained \n"
"\t\t\t\tproperly the new concepts become as intuitive as the original \n"
"building blocks that aided their understanding. That was the problem! \n"
"\t\t\t\tMetaprogramming, code and data in one representation, self-"
"modifying\n"
" programs, domain specific mini-languages, none of the \n"
"\t\t\t\texplanations for these concepts referenced familiar territory. How \n"
"could I expect anyone to understand them! No wonder people wanted \n"
"\t\t\t\tspecific examples. I could as well have been speaking in Martian!</p>"
msgstr ""
"<p>Я тщательно обдумал этот вопрос. Есть ли в Лиспе что-то сложное, что "
"мешает очень умным, опытным\n"
"программистам понять это? Нет! В конце концов, я же получил это, и если я "
"смог сделать это, любой\n"
"сможет. Тогда что же делает Лисп делает таким трудным для понимания? Ответ, "
"как обычно делают такие\n"
"вещи, пришел неожиданно. Конечно! Обучение кого-либо чему-либо включает в "
"себя построение передовых\n"
"концепций поверх тех концепций, которые они уже понимают! Если процесс "
"становится интересным, и вопрос\n"
"объясняется должным образом, новые концепции становятся такими же "
"интуитивными, как и исходные \n"
"строительные блоки, которые помогают их пониманию. Это была проблема! \n"
"Метапрограммирование, единообразное представление кода и данных, "
"самоизменяющиеся программы, предметно ориентированные мини языки(DSL), ни "
"одно из объяснений этих концепций не относятся к территории знакомой\n"
"обычному программисту. Как я мог ожидать, что кто-нибудь поймет их?! "
"Неудивительно, что люди хотели\n"
"конкретных примеров. С таким же успехом я мог бы говорить по марсиански!\n"
"</p>"

#: in/NatureOfLisp.htm:165
msgid ""
"<p>I shared my ideas with fellow Lispers. \"Well, of course these \n"
"concepts aren't explained in terms of familiar territory\", they said. \n"
"\t\t\t\t\"They are so different, they're unlike anything these people have \n"
"learned before.\" This was a poor excuse. \"I do not believe this to \n"
"\t\t\t\tbe true\", I said. The response was unanimous: \"Why don't you give "
"it\n"
" a try?\" So I did. This article is a product of my efforts. It is \n"
"\t\t\t\tmy attempt to explain Lisp in familiar, intuitive concepts. I urge \n"
"brave souls to read on. Grab your favorite drink. Take a deep \n"
"\t\t\t\tbreath. Prepare to be blown away. Oh, and may the Force be with you."
"</p>"
msgstr ""
"<p>Я поделился своими идеями со знакомыми Лисперами. \"Ну конечно, эти "
"понятия не объясняются\n"
"с точки зрениия привычных практик обычных программистов\", сказали они. "
"\"Они настолько иные,\n"
"настолько непохожи ни на что, чему эти люди учились ранее\". Это было плохое "
"оправдание. \n"
"\"Я не верю, что это правда\", сказал я. Ответ был единодушным: \"Почему бы "
"тебе не попробовать?\".\n"
"Так я и сделал. Эта статья является продуктом моих усилий. Это моя попытка "
"объяснить Лисп, в \n"
"терминах знакомых, интуитивных понятий. Я призываю храбрые души читать "
"дальше. Взять свой любмый\n"
"напиток, сделать глубокий вдох. Приготовиться к тому, что вас унесет "
"ветром.  О, и да пребудет\n"
"с вами Сила.\n"
"</p>"

#: in/NatureOfLisp.htm:180
msgid ""
"\t\t\t\t<h2><a id=\"part_2\">XML Reloaded</a></h2>\n"
"\t\t\t\t<p class=\"first\">A thousand mile journey starts with a single "
"step. A\n"
" journey to enlightenment is no exception and our first step just \n"
"happens to be \n"
"\t\t\t\tXML. What more could possibly be said about XML that hasn't "
"already \n"
"been said? It turns out, quite a bit. While there's nothing \n"
"\t\t\t\tparticularly interesting about XML itself, its relationship to "
"Lisp \n"
"is fascinating. XML is the all too familiar concept that Lisp \n"
"\t\t\t\tadvocates need so much. It is our bridge to conveying "
"understanding \n"
"to regular programmers. So let's revive the dead horse, take out \n"
"\t\t\t\tthe stick, and venture into XML wilderness that no one dared "
"venture\n"
" into before us. It's time to see the all too familiar moon from \n"
"\t\t\t\tthe other side.</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_2\">XML Перезагрузка</a></h2>\n"
"\t\t\t\t<p class=\"first\">Путешествие в тысячу миль начинается с одного "
"шага. \n"
"Путь к просветелению не является исключением, и наш первый шаг - это XML. "
"Что можно еще сказать о\n"
"XML, чего еще не было сказано? Оказывается, совсем не много. Хотя нет ничего "
"осоебнно интересного в\n"
"самом XML, его отношение к Лиспу впечатляет. XML - это слишком знакомая "
"концепция, в которой так нуждается\n"
"сторонник Лиспа. Это наш мост для передачи ПОНИМАНИЯ обычным программистам. "
"Итак, давайте возродим мертвую\n"
"лошадь, вытащим кнут и отправимся в дикую природу XML, в которую никто не "
"осмеливался сунуться до нас. Пришло\n"
"время увидеть слишком знакомую луну с ДРУГОЙ стороны.\n"
"</p>"

#: in/NatureOfLisp.htm:189
msgid ""
"<p>Superficially XML is nothing more than a standardized syntax used\n"
" to express arbitrary hierarchical data in human readable form. \n"
"\t\t\t\tTo-do lists, web pages, medical records, auto insurance claims, \n"
"configuration files are all examples of potential XML use. Let's use \n"
"\t\t\t\ta simple to-do list as an example (in a couple of sections you'll \n"
"see it in a whole new light):</p>"
msgstr ""
"<p>Внешне XML - это не что иное, как стандартизированный синтаксис, "
"используемый для выражения\n"
"произвольных иерархических данных в удобочитаемой форме. Списки дел, веб "
"страницы, медицинские\n"
"записи, страховые возмещения, файлы конфигурации - всё это примеры "
"потенциального использоания XML. \n"
"Давайте используем простой список дел в качестве примера (в нескольких "
"разделах вы увидите его\n"
"в совершенно новом свете):\n"
"</p>"

#: in/NatureOfLisp.htm:197
msgctxt "in/NatureOfLisp.htm:197"
msgid ""
"<pre>&lt;todo name=\"housework\"&gt;\n"
"    &lt;item priority=\"high\"&gt;Clean the house.&lt;/item&gt;\n"
"    &lt;item priority=\"medium\"&gt;Wash the dishes.&lt;/item&gt;\n"
"    &lt;item priority=\"medium\"&gt;Buy more soap.&lt;/item&gt;\n"
"&lt;/todo&gt;\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:206
msgid ""
"<p>What happens if we unleash our favorite XML parser on this to-do \n"
"list? Once the data is parsed, how is it represented in memory? The \n"
"\t\t\t\tmost natural representation is, of course, a tree - a perfect data \n"
"structure for hierarchical data. After all is said and done, XML is \n"
"\t\t\t\treally just a tree serialized to a human readable form. Anything \n"
"that can be represented in a tree can be represented in XML and vice \n"
"\t\t\t\tversa. I hope you understand this idea. It's very important for \n"
"what's coming next.</p>"
msgstr ""
"<p>Что произойдет, если мы применим наш любмый анализатор(парсер) XML к "
"этому списку дел? \n"
"Как только данные проанализируются, как они разместятся в памяти? Конечно, "
"наиболее естественным\n"
"представлением является дерево - идеальная структура данных для "
"иерархических данных. После всего\n"
"сказанного и сделанного, XML на самом деле представляет собой просто дерево, "
"сериализованное\n"
"в удобочитаемую форму. Все что может быть представлено в виде дерева, может "
"быть представлено в\n"
"XML и наоборот. Я надеюсь вы понимаете эту идею. Это очень важно, для "
"понимания того, что будет\n"
"дальше.\n"
"</p>"

#: in/NatureOfLisp.htm:219
msgid ""
"<p>Let's take this a little further. What other type of data is \n"
"often represented as a tree? At this point the list is as good as \n"
"\t\t\t\tinfinite so I'll give you a hint at what I'm getting at - try to \n"
"remember your old compiler course. If you have a vague recollection \n"
"\t\t\t\tthat source code is stored in a tree after it's parsed, you're on \n"
"the right track. Any compiler inevitably parses the source code \n"
"\t\t\t\tinto an abstract syntax tree. This isn't surprising since source \n"
"code is hierarchical: functions contain arguments and blocks of code. \n"
"\t\t\t\tBlocks of code contain expressions and statements. Expressions \n"
"contain variables and operators. And so it goes.</p>"
msgstr ""
"<p>Давайте рассмотрим это немного дальше. Какой другой тип данных часто "
"представляется в виде дерева?\n"
"На данный момент этот список практически бесконечен, поэтому я дам вам "
"подсказку, к чему я клоню -\n"
"попробуйте вспомнить ваш старый курс по компиляторам. Если у вас есть "
"смутное воспоминание о том, что\n"
"исходный код сохраняется в виде дерева после анализа, вы на правильном пути. "
"Любой комплятор неизбежно\n"
"анализирует исходный код в абстрактном синтаксическом дереве(AST). Это "
"неудивительно, поскольку сам исходный\n"
"код является иерархическим: функции содержат арументы и блоки кода. Блоки "
"кода содержат выражения и операторы. Выражения содержат переменные и "
"операторы. И так далее.\n"
"</p>"

#: in/NatureOfLisp.htm:228
msgid ""
"<p>Let's apply our corollary that any tree can easily be serialized \n"
"into XML to this idea. If all source code is eventually represented \n"
"\t\t\t\tas a tree, and any tree can be serialized into XML, then all "
"source \n"
"code can be converted to XML, right? Let's illustrate this \n"
"\t\t\t\tinteresting property by a simple example. Consider the function \n"
"below:</p>"
msgstr ""
"<p>Давайте применим наше заключение о том, что любое дерево может быть легко "
"преобразовано в\n"
"XML для этой идеи. Если весь исходный код в конечном итоге представляется в "
"виде дерева, и любое\n"
"дерево может быть сериализовано в  XML, то весь исходный код можно "
"преобразовать в XML, верно? \n"
"Давайте проилиюстрируем это интересное свойство на простом примере. "
"Рассмотрим функцию ниже:\n"
"</p>"

#: in/NatureOfLisp.htm:236
msgid ""
"<pre>\t\t\t\t\n"
"int add(int arg1, int arg2)\n"
"{\n"
"    return arg1 + arg2;\n"
"}\n"
"</pre>\t\t\t"
msgstr ""

#: in/NatureOfLisp.htm:240
msgid ""
"<p>Can you convert this function definition to its XML equivalent? \n"
"Turns out, it's reasonably simple. Naturally there are many ways to \n"
"\t\t\t\tdo this. Here is one way the resulting XML can look like:</p>"
msgstr ""
"<p>Можете ли вы преобразовать это определение функции в его XML эквивалент? "
"Оказывается, это\n"
"достаточно просто. Естественно, есть много способов сделать это. Вот один из "
"этих способов,\n"
"применением которого полученный XML может выглядеть так:\n"
"</p>"

#: in/NatureOfLisp.htm:254
msgid ""
"<pre>&lt;define-function return-type=\"int\" name=\"add\"&gt;\n"
"    &lt;arguments&gt;\n"
"        &lt;argument type=\"int\"&gt;arg1&lt;/argument&gt;\n"
"        &lt;argument type=\"int\"&gt;arg2&lt;/argument&gt;\n"
"    &lt;/arguments&gt;\n"
"    &lt;body&gt;\n"
"        &lt;return&gt;\n"
"            &lt;add value1=\"arg1\" value2=\"arg2\" /&gt;\n"
"        &lt;/return&gt;\n"
"    &lt;/body&gt;\n"
"&lt;/define&gt;\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:257
msgid ""
"<p>We can go through this relatively simple exercise with any \n"
"language. We can turn any source code into XML, and we can transform the"
msgstr ""
"<p>Мы можем пройти это относительно простое упражнение на любом языке. Мы "
"можем превратить\n"
"любой исходный код в XML."

#: in/NatureOfLisp.htm:262
msgid ""
"\t\t\t\tresulting XML back to original source code. We can write a "
"converter\n"
" that turns Java into XML and a converter that turns XML back to \n"
"\t\t\t\tJava. We could do the same for C++. (In case you're wondering if \n"
"anyone is crazy enough to do it, take a look at <a href=\"http://www.gccxml."
"org/\">GCC-XML</a>)."
msgstr ""
"и преобразовать полученный XML обратно в исходный код. Мы можем написать "
"конвертер, который\n"
"превращает Java в XML и конвертер, который превращает XML обратно в Java. Мы "
"могли бы сделать\n"
"тоже самое для C++. (В случае если вам интересно, достаточно ли это безумно, "
"чтобы делать это,\n"
"взгляните на <a href=\"http://www.gccxml.org/\">GCC-XML</a>)."

#: in/NatureOfLisp.htm:271
msgid ""
"\t\t\t\tFurthermore, for languages that share common features but use \n"
"different syntax (which to some extent is true about most mainstream \n"
"\t\t\t\tlanguages) we could convert source code from one language to "
"another\n"
" using XML as an intermediary representation. We could use our \n"
"\t\t\t\tJava2XML converter to convert a Java program to XML. We could then \n"
"run an XML2CPP converter on the resulting XML and turn it into \n"
"\t\t\t\tC++ code. With any luck (if we avoid using features of Java that \n"
"don't exist in C++) we'll get a working C++ program. Neat, eh?</p>"
msgstr ""
"Кроме того, для языков, которые имеют общие функции, но используют другой "
"синтаксис (что в некоторой\n"
"степени верно для большинства основных языков), мы можем преобразовать "
"исходный код с одного языка на\n"
"другой используя XML в качестве промежуточного представления. Мы могли бы "
"использовать наш конвертер \n"
"Java2XML для преобразования программы Java в XML. Затем мы могли бы "
"запустить конвертер XML2CPP для\n"
"полученного XML и превратить его в код на C++. Если повезет (если мы будем "
"избегать использования\n"
"специфичных  функций Java, которых нет в C++), мы получим работающую "
"программу на C++. Ловко, а?</p>"

#: in/NatureOfLisp.htm:282
msgid ""
"<p>All this effectively means that we can use XML for generic \n"
"storage of source code. We'd be able to create a whole class of \n"
"\t\t\t\tprogramming languages that use uniform syntax, as well as write \n"
"transformers that convert existing source code to XML. If we were to \n"
"\t\t\t\tactually adopt this idea, compilers for different languages "
"wouldn't\n"
" need to implement parsers for their specific grammars - they'd \n"
"\t\t\t\tsimply use an XML parser to turn XML directly into an abstract \n"
"syntax tree.</p>"
msgstr ""
"<p>Все это фактически означает, что мы можем использовать XML как общее "
"хранилище исходного кода. \n"
"Мы можем создать целый класс языков программирования, которые используют "
"унифицированный синтаксис,\n"
"а также написать преобразователи, котоыре преобразуют существующий исходный "
"код в XML. Если бы мы\n"
"на самом деле приняли эту идею, компиляторы разных языков не должны были бы "
"реализовывать парсеры\n"
"(анализаторы) для своих конкретных граматик - они просто использовали бы "
"парсер XML, чтобы превратить\n"
"XML непосредственно в абстрактное синтаксическое дерево.\n"
"</p>"

#: in/NatureOfLisp.htm:305
msgid ""
"<p>By now you're probably wondering why I've embarked on the XML \n"
"crusade and what it has to do with Lisp (after all, Lisp was created \n"
"\t\t\t\tabout thirty years before XML). I promise that everything will \n"
"become clear soon enough. But before we take our second step, let's go \n"
"\t\t\t\tthrough a small philosophical exercise. Take a good look at the "
"XML \n"
"version of our \"add\" function above. How would you \n"
"\t\t\t\tclassify it? Is it data or code? If you think about it for a "
"moment \n"
"you'll realize that there are good reasons to put this XML \n"
"\t\t\t\tsnippet into both categories. It's XML and it's just information \n"
"encoded in a standardized format. We've already determined that it \n"
"\t\t\t\tcan be generated from a tree data structure in memory (that's \n"
"effectively what GCC-XML does). It's lying around in a file with no \n"
"\t\t\t\tapparent way to execute it. We can parse it into a tree of XML "
"nodes\n"
" and do various transformations on it. It's data. But wait a \n"
"\t\t\t\tmoment! When all is said and done it's the same \"add\" function \n"
"written with a different syntax, right? Once parsed, its tree could be \n"
"\t\t\t\tfed into a compiler and we could execute it. We could easily write "
"a\n"
" small interpreter for this XML code and we could execute it \n"
"\t\t\t\tdirectly. Alternatively, we could transform it into Java or C++ \n"
"code, compile it, and run it. It's code.</p>"
msgstr ""
"<p>К настоящему времени вы, вероятно, задаетесь вопросом, почему я начал "
"\"крестовый\" поход на\n"
"XML и как он связан с Лиспом.(в конце концов, Лисп был создан примерно за 30 "
"лет до появления\n"
"XML). Обещаю, что скоро все станет ясно. Но прежде чем мы сделаем второй "
"шаг, давайте пройдем\n"
"небольшое филосовское упражнение. Внимательно посмотрите на  XML версию "
"нашей функции \"add\",\n"
"приведенной выше. Как бы вы её классифицировали? Это данные или код? Если вы "
"задумаетесь об\n"
"этом на мгновение, вы поймете, что есть веские причины для помещения этого "
"фрагмента XML \n"
"в обе категории. Это XML, и это просто информация , закодированная в "
"стандартном формате.\n"
"Мы уже определили, что она может быть сгенерирована из древовидной структуры "
"данных в памяти\n"
"(это, фактически, то что делает GCC-XML). Она лежит в файле без видимого "
"способа её выполнения.\n"
"Мы можем разобрать ее в дерево узлов XML и сделать с ним различные "
"преобразования. Это данные. \n"
"Но подождите минутку! Когда все сказано и сделано, это таже самая функция "
"\"add\", написанная\n"
"другим синтаксисом, верно? После ее анализа, дерево может быть передано в "
"компилятор, и мы сможем\n"
"выполнить её. Мы могли бы легко написать небольшой интерпретатор дя этого "
"XML кода и выполнять\n"
"его напрямую. В качестве альтернативы, мы могли бы преобразовать его в код "
"Java или C++, \n"
"скомпилировать его, и запустить. Это код.\n"
"</p>"

#: in/NatureOfLisp.htm:316
msgid ""
"<p>So, where are we? Looks like we've just arrived to an interesting\n"
" point. A concept that has traditionally been so hard to understand \n"
"\t\t\t\tis now amazingly simple and intuitive. Code is also always data! \n"
"Does it mean that data is also always code? As crazy as this sounds \n"
"\t\t\t\tthis very well might be the case. Remember how I promised that \n"
"you'll see our to-do list in a whole new light? Let me reiterate on \n"
"\t\t\t\tthat promise. But we aren't ready to discuss this just yet. For "
"now \n"
"let's continue walking down our path.</p>"
msgstr ""
"<p>Итак, где мы? Похоже мы пришли к интересному положению. Концепция, "
"которую раньше было так сложно\n"
"понять, теперь удивительно проста и интуитивно понятна. Код это тоже всегда  "
"данные! \n"
"Означает ли это, что данные это всегда код? Как бы безумно это не звучало, "
"но это вполне может иметь\n"
"место. Помните, как я обещал, что вы увидите наш список дел в совершенно "
"новом свете? Позвольте мне \n"
"повторить это обещание. Но пока мы не готовы обсуждать это. А пока давайте "
"продолжим идти по нашему\n"
"пути.\n"
"</p>"

#: in/NatureOfLisp.htm:327
msgid ""
"<p>A little earlier I mentioned that we could easily write an \n"
"interpreter to execute our XML snippet of the add function. Of course \n"
"this \n"
"\t\t\t\tsounds like a purely theoretical exercise. Who in their right mind \n"
"would want to do that for practical purposes? Well, it turns out \n"
"\t\t\t\tquite a few people would disagree. You've likely encountered and \n"
"used their work at least once in your career, too. Do I have you \n"
"\t\t\t\tout on the edge of your seat? If so, let's move on!</p>"
msgstr ""
"<p>Чуть раньше я упомянул, что мы могли бы написать интерпретатор для "
"выполнения нашего\n"
"фрагмента XML функции add. Конечно, это звучит как чисто теоретическое "
"упражнение. Кто в здравом\n"
"уме захочет сделать это в практических целях? Что ж, оказывается, довольно "
"много людей с этим\n"
"не согласились. Скорее всего, вы встречали и использовали их работу хотябы "
"раз в своей карьере.\n"
"Вы еще не ушли? Если так, давайте двигаться дальше!\n"
"</p>"

#: in/NatureOfLisp.htm:351
msgid ""
"\t\t\t\t<h2><a id=\"part_3\">Ant Reloaded</a></h2>\n"
"\t\t\t\t<p class=\"first\">Now that we've made the trip to the dark side "
"of \n"
"the moon, let's not leave quite yet. We may still learn something by \n"
"exploring it a \n"
"\t\t\t\tlittle more, so let's take another step. We begin by closing our \n"
"eyes and remembering a cold rainy night in the winter of 2000. A \n"
"\t\t\t\tprominent developer by the name of James Duncan Davidson<sup><a href="
"\"#note-james\">1</a></sup> was hacking his way through\n"
"\t\t\t\t<a href=\"http://tomcat.apache.org/\">Tomcat</a> servlet container. "
"As the time came to build the changes he carefully saved all his files\n"
"\t\t\t\tand ran <em>make</em>. Errors. Lots of errors. Something was "
"wrong. \n"
"After careful examination James exclaimed: \"Is my command not executing\n"
"\t\t\t\tbecause I have a space in front of my tab?!\" Indeed, this was the \n"
"problem. Again. James has had enough. He could sense the full moon \n"
"through\n"
"\t\t\t\tthe clouds and it made him adventurous. He created a fresh Java\t\n"
"project and quickly hacked together a simple but surprisingly useful\n"
"\t\t\t\tutility. This spark of genius used Java property files for\t\n"
"information on how to build the project. James could now write the \n"
"equivalent\n"
"\t\t\t\tof the makefile in a nice format without worrying about\tthe "
"damned \n"
"spaces ever again. His utility did all the hard work by interpreting\n"
"\t\t\t\tthe property file and taking appropriate actions to build the \n"
"project. It was neat. Another Neat Tool. <a href=\"http://ant.apache.org/"
"\">Ant</a>.</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_3\">Ant Перезагрузка</a></h2>\n"
"\t\t\t\t<p class=\"first\">Теперь, когда мы совершили путешествие на темную\n"
"строну луны, давайте пока не будет отсюда уходить. Мы все еще можем чему-то "
"научиться, проводя наши \n"
"исследования немного глубже. Мы начнем с того, что закроем глаза и вспомним "
"холодную дождливую ночь зимой 2000\n"
"года. Известный разработчик Джеймс Дункан Девидсон(James Duncan "
"Davidson)<sup><a href=\"#note-james\">1</a></sup> \n"
"пробирался через контейнер сервлетов <a href=\"http://tomcat.apache.org/"
"\">Tomcat</a>. Когда пришло время\n"
"сохранить изменения, он тщательно сохранил все свои файлы и запустил "
"<em>make</em>. Ошибки. МНОГО ошибок. \n"
"Что-то пошло не так! После тщательного изучения проблемы Джеймс воскликнул: "
"\"Моя команда не выполняется,\n"
"потому что у меня стоит пробел перед моей табуляцией(в команде make)?!\". "
"Действительно, это была проблема.\n"
"Потом опять. С Джемса этого было достаточно. Он смог почувствовать холодную "
"луну сквозь облака и это сделало\n"
"его авантюристом. Он создал свежий Java проект и быстро собрал простую, но "
"удивительно полезную утилиту.\n"
"Эта искра гения использовала файлы свойств Java для получения информации о "
"том, как строить проект. Теперь\n"
"Джеймс мог написать эквивалент makefile в хорошем формате, не беспокоясь о "
"проклятых пробелах. Его утилита\n"
"выполняла всю тяжелую работу, интерпретируя файл свойств и выполняя "
"соответствующие действия для построения\n"
"проекта. Это было ловко! Еще один Ловкий инструмент(Another Neat Tool). <a "
"href=\"http://ant.apache.org/\">Ant</a>.\n"
"</p>"

#: in/NatureOfLisp.htm:367
msgid ""
"<p>After using Ant to build Tomcat for a few months it became clear \n"
"that Java property files are not sufficient to express complicated \n"
"\t\t\t\tbuild instructions. Files needed to be checked out, copied, \n"
"compiled, sent to another machine, and unit tested. In case of failure \n"
"\t\t\t\te-mails needed to be sent out to appropriate people. In case of \n"
"success \"Bad to the Bone\" needed to be played at the highest possible \n"
"\t\t\t\tvolume. At the end of the track volume had to be restored to its \n"
"original level. Yes, Java property files didn't cut it anymore. \n"
"\t\t\t\tJames needed a more flexible solution. He didn't feel like writing \n"
"his own parser (especially since he wanted an industry standard \n"
"\t\t\t\tsolution). XML seemed like a reasonable alternative. In a couple "
"of \n"
"days Ant was ported to XML. It was the best thing since sliced \n"
"\t\t\t\tbread.</p>"
msgstr ""
"<p>После использования Ant для сборки Tomcat в течении нескольких месяцев "
"стало ясно, что файлов\n"
"свойств Java недостаточно для выражения сложных инструкций по сборке. Файлы "
"должны быть проверены,\n"
"скопированы, скомпилированы, отправлены на другой компьютер и "
"протестированы. В случае неудачи\n"
"электронные письма должны быть отправлены соответствующим людям. В случае "
"успеха \"Bad to the Bone\"\n"
"нужно было играть с максимально возможной громкостью. В конце трека "
"громкость нужно было восстанавливать\n"
"до исходного уровня. Да, файлов свойств Java уже было маловато. Джеймсу "
"необхдимо было более гибкое\n"
"решение. Ему не хотелось писать собственный парсер (тем более, что он хотел "
"стандартного решения). \n"
"XML казался разумной альтернативой. Через пару дней Ant был перенесен на "
"XML. Это была лучшая вещь\n"
"со времен изобретения нарезанного хлеба(присказка такая английская, "
"используемая для того чтобы\n"
"показать маштаб/величину/значение проделанной работы).</p>"

#: in/NatureOfLisp.htm:376
msgid ""
"<p>So how does Ant work? It's pretty simple. It takes an XML file \n"
"with specific build instructions (you decide if they're data or code) \n"
"\t\t\t\tand interprets them by running specialized Java code for each XML \n"
"element. It's actually much simpler than it sounds. A simple XML \n"
"\t\t\t\tinstruction like the one below causes a Java class with an \n"
"equivalent name to be loaded and its code to be executed.</p>"
msgstr ""
"<p>Так как работает Ant? Это довольно просто. Он берет файл XML со "
"специальными инструкциями по\n"
"сборке (вы уж сами решайте, являются ли они данными или кодом) и "
"интерпретирует их, выполняя\n"
"специализированный код Java для каждого элемента XML. Это на много проще, "
"чем кажется. Простая\n"
"инструкция XML подобная приведенной ниже, вызывает загрузку Java класса с "
"эквивалентным именем\n"
"и выполнение его кода.\n"
"</p>"

#: in/NatureOfLisp.htm:382
msgctxt "in/NatureOfLisp.htm:382"
msgid ""
"<pre>&lt;copy todir=\"../new/dir\"&gt;\n"
"    &lt;fileset dir=\"src_dir\"/&gt;\n"
"&lt;/copy&gt;\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:400
msgid ""
"<p>The snippet above copies a source directory to a destination \n"
"directory. Ant locates a \"copy\" task (a Java class, really), sets \n"
"\t\t\t\tappropriate parameters (todir and fileset) by calling appropriate \n"
"Java methods and then executes the task. Ant comes with a set of \n"
"\t\t\t\tcore tasks and anyone can extend it with tasks of their own simply \n"
"by writing Java classes that follow certain conventions. Ant finds \n"
"\t\t\t\tthese classes and executes them whenever XML elements with \n"
"appropriate names are encountered. Pretty simple. Effectively Ant \n"
"\t\t\t\taccomplishes what we were talking about in the previous section: "
"it \n"
"acts as an interpreter for a language that uses XML as its syntax \n"
"\t\t\t\tby translating XML elements to appropriate Java instructions. We \n"
"could write an \"add\" task and have Ant execute it when it encounters \n"
"\t\t\t\tthe XML snippet for addition presented in the previous section! \n"
"Considering that Ant is an extremely popular project, the ideas \n"
"\t\t\t\tpresented in the previous section start looking more sane. After \n"
"all, they're being used every day in what probably amounts to \n"
"\t\t\t\tthousands of companies!</p>"
msgstr ""
"<p>Приведенный выше фрагмент кода копирует исходный каталог в целевой "
"каталог. Ant находит задачу\n"
"\"copy\"  (на самом деле класс Java), устанавливает соответствующие "
"параметры (todir и fileset), \n"
"вызывая соответствующие методы Java, а затем выполняет задачу. Ant "
"поставляется с набором основных\n"
"задач, и любой может расширить его своими собственными задачами, просто "
"написав Java классы, которые\n"
"следуют определенным соглашениям. Ant находит эти классы и выполняет их "
"всякий раз, когда встречаются\n"
"элементы XML с соответствующими именами. Довольно просто. По сути, Ant "
"выполняет то, о чем мы говорили\n"
"в предыдущем разделе: он выступает в роли интерпретатора языка, который "
"использует XML в качестве\n"
"синтаксиса, переводя элементы XML в соответствующие инструкции Java. Мы "
"могли бы написать задачу \"add\"\n"
"и заставить Ant выполнить её при обнаружении фрагмента XML для добавления, "
"представленного в предыдущем\n"
"разделе! \n"
"Учитывая, что Ant - чрезвычайно популярный проект, идеи представленные в "
"предыдущем разделе, начинают\n"
"казаться более разумными. В конце концов, они используются каждый день в "
"том, что вероятно, работает\n"
"в тысячах компаний!\n"
"</p>"

#: in/NatureOfLisp.htm:408
msgid ""
"<p>So far I've said nothing about why Ant actually goes through all \n"
"the trouble of interpreting XML. Don't try to look for the answer on \n"
"\t\t\t\tits website either - you'll find nothing of value. Nothing "
"relevant \n"
"to our discussion, anyway. Let's take another step. It's time to \n"
"\t\t\t\tfind out why.</p>"
msgstr ""
"<p>До сих пор я ничего не говорил, почему Ant на самом деле проходит через "
"все трудности\n"
"интерпретации XML. Не пытайтесь искать ответ на его веб сайте - вы не "
"найдете ничего ценного. \n"
"Во всяком случае, ничего общего с нашей дисскусией. Давайте сделаем еще один "
"шаг.\n"
"Пришло время выяснить, ПОЧЕМУ.\n"
"</p>"

#: in/NatureOfLisp.htm:426
msgid ""
"\t\t\t\t<h2><a id=\"part_4\">Why XML?</a></h2>\n"
"\t\t\t\t<p class=\"first\">Sometimes right decisions are made without full "
"conscious\n"
"\t\t\t\tunderstanding of all the issues involved. I'm not sure if James\n"
"\t\t\t\tknew why he chose XML - it was likely a subconscious decision.\n"
"\t\t\t\tAt the very least, the reasons I saw on Ant's website for using\n"
"\t\t\t\tXML are all the wrong reasons. It appears that the main concerns\n"
"\t\t\t\trevolved around portability and extensibility. I fail to see how\n"
"\t\t\t\tXML helps advance these goals in Ant's case. What is the\n"
"\t\t\t\tadvantage of using interpreted XML over simple Java source code?\n"
"\t\t\t\tWhy not create a set of classes with a nice API for commonly\n"
"\t\t\t\tused tasks (copying directories, compiling, etc.) and using\n"
"\t\t\t\tthose directly from Java source code? This would run on every\n"
"\t\t\t\tplatform that runs Java (which Ant requires anyway), it's\n"
"\t\t\t\tinfinitely extensible, and it has the benefit of having a more\n"
"\t\t\t\tpleasant, familiar syntax. So why XML? Can we find a good reason\n"
"\t\t\t\tfor using it?</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_4\">Почему XML?</a></h2>\n"
"\t\t\t\t<p class=\"first\">Иногда правильные решения принимаются без "
"полного\n"
"осознанного понимания всех проблем. Я не уверен, знал ли Джеймс, почему он "
"выбрал  XML - это было,\n"
"вероятно подсознательное решение. По крайней мере, причины, которые я видел "
"на веб-сайте Ant \n"
"обосновывающие использование XML, - это не правильные причины. Похоже, что "
"основные проблемы были\n"
"связаны с переносимостью и расширяемостью. Я не понимаю, как XML помогает "
"продвигать эти цели в \n"
"случае с Ant. В чем преимущество использования интерпретируемого XML над "
"простым исходным кодом\n"
"Java?\n"
"Почему бы не создать набор классов с хорошим API(как это сделано в ASDF) для "
"часто используемых\n"
"задач (копирования каталогов, компилирования и т.д.) и использовать их "
"непосредственно из\n"
"исходного кода Java? Это будет работать на любой платформе Java(которая в "
"любом случае требуется\n"
"для Ant/прим. переводчика: на самом деле это будет работать, только на "
"платформах где установлен \n"
"компилятор Java, а для работы ant достаточно виртуальной машины Java), "
"он(код) бесконечно расширяем\n"
"и имеет преимущество, заключающееся в более приятном, знакомом синтаксисе. "
"Так почему же XML? \n"
"Можем ли мы найти вескую причину для его использования?\n"
"</p>"

#: in/NatureOfLisp.htm:438
msgid ""
"<p>It turns out that we can (although as I mentioned earlier I'm\n"
"\t\t\t\tnot sure if James was consciously aware of it). XML has the\n"
"\t\t\t\tproperty of being far more flexible in terms of introduction of\n"
"\t\t\t\tsemantic constructs than Java could ever hope to be. Don't\n"
"\t\t\t\tworry, I'm not falling into the trap of using big words to\n"
"\t\t\t\tdescribe incomprehensible concepts. This is actually a\n"
"\t\t\t\trelatively simple idea, though it may take some effort to\n"
"\t\t\t\texplain. Buckle your seat-belt. We're about to make a giant leap\n"
"\t\t\t\ttowards achieving nirvana.</p>"
msgstr ""
"<p>Оказывается, МОЖЕМ!(хотя, как я упоминал ранее, я не уверен, осознавал ли "
"это Джеймс). \n"
"У XML есть свойство быть гораздо более гибким с точки зрения введения "
"семантических\n"
"конструкций, чем Java могла бы когда либо надеятся. Не волнуйтесь, я не "
"попаду в ловушку\n"
"использования громких слов для описания непонятных понятий. На самом деле "
"это относительно\n"
"простая идея, хотя для её объяснения может потребоваться некоторое усилие. "
"Пристегните\n"
"ремень безопасности. Мы собираемся совершить гиганский скачок к достижению "
"нирваны.\n"
"</p>"

#: in/NatureOfLisp.htm:442
msgid ""
"<p>How can we represent 'copy' example above in Java code? Here's one way to "
"do it:</p>"
msgstr ""
"<p>Как мы можем представить пример копирования - 'copy' в виде кода Java? "
"Вот один из\n"
"способов сделать это:</p>"

#: in/NatureOfLisp.htm:446
msgid ""
"<pre>CopyTask copy = new CopyTask();\n"
"Fileset fileset = new Fileset();"
msgstr ""

#: in/NatureOfLisp.htm:450
msgid ""
"fileset.setDir(\"src_dir\");\n"
"copy.setToDir(\"../new/dir\");\n"
"copy.setFileset(fileset);"
msgstr ""

#: in/NatureOfLisp.htm:453
msgid ""
"copy.execute();\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:458
msgid ""
"<p>The code is almost the same, albeit a little longer than the original "
"XML. So\n"
"\t\t\t\twhat's different? The answer is that the XML snippet introduces a\n"
"\t\t\t\tspecial semantic construct for copying. If we could do it in Java it "
"would look\n"
"\t\t\t\tlike this:</p>"
msgstr ""
"<p>Код почти такой же, хотя и немного длиннее исходного XML. Так что же "
"отличается? Ответ заключается\n"
"в том, что фрагмент XML вводит(представляет) специальную семантическую "
"конструкцию для копирования.\n"
"Если бы мы могли сделать это на Java, это выглядело бы так:</p>"

#: in/NatureOfLisp.htm:466
msgid ""
"<pre>\t\t\n"
"copy(\"../new/dir\")\n"
"{\n"
"    fileset(\"src_dir\");\n"
"}\n"
"</pre>\t\t\t\t"
msgstr ""

#: in/NatureOfLisp.htm:479
msgid ""
"<p>Can you see the difference? The code above (if it were possible\n"
"\t\t\t\tin Java) is a special operator for copying files - similar to a\n"
"\t\t\t\t<em>for</em> loop or a new <em>foreach</em> construct introduced in "
"Java 5. If we\n"
"\t\t\t\thad an automatic converter from XML to Java it would likely\n"
"\t\t\t\tproduce the above gibberish. The reason for this is that Java's\n"
"\t\t\t\taccepted syntax tree grammar is fixed by the language\n"
"\t\t\t\tspecification - we have no way of modifying it. We can add\n"
"\t\t\t\tpackages, classes, methods, but we cannot extend Java to make\n"
"\t\t\t\taddition of new operators possible. Yet we can do it to our\n"
"\t\t\t\theart's content in XML - its syntax tree isn't restricted by\n"
"\t\t\t\tanything except our interpreter! If the idea is still unclear,\n"
"\t\t\t\tconsider introducing a special operator 'unless' to Java:</p>"
msgstr ""
"<p>Вы видите разницу? Приведенный выше код (если бы это было возможно в "
"Java) представляет собой\n"
"специальный оператор для копирования файлов - аналогичный циклу <em>for</em> "
"или новой конструкции\n"
"<em>foreach</em>, представленной в Java 5. Если бы у нас был автоматический "
"преобразователь из XML\n"
"в Java, он скорее всего, произвел бы описанную выше тарабарщину. Причина "
"этого заключается в том,\n"
"что принятая граматика синтаксического дерева Java фиксируется спецификацией "
"языка - у нас нет\n"
"способа её изменить. Мы можем добавлять пакеты, классы, методы, но мы не "
"можем расширять Java,\n"
"чтобы сделать возможным добавление новых операторов. Тем не менее, мы можем "
"делать это,\n"
"сколько душе угодно, в XML - его синтаксическое дерево не ограничено ничем, "
"кроме нашего\n"
"интерпретатора! Если идея все еще не ясна, подумайте о введении специального "
"оператора (если не) 'unless'\n"
"в Java:\n"
"</p>"

#: in/NatureOfLisp.htm:487
msgid ""
"<pre>\t\t\t\t\n"
"unless(someObject.canFly())\n"
"{\n"
"    someObject.transportByGround();\n"
"}\n"
"</pre>\t\t\t\t"
msgstr ""

#: in/NatureOfLisp.htm:494
msgid ""
"<p>In the previous two examples we extend the Java language to introduce an\n"
"\t\t\t\toperator for copying files and a conditional operator <em>unless</"
"em>. We would do this\n"
"\t\t\t\tby modifying the abstract syntax tree grammar that Java compiler "
"accepts.\n"
"\t\t\t\tNaturally we cannot do it with standard Java facilities, but we can "
"easily do it\n"
"\t\t\t\tin XML. Because our XML interpreter parses the abstract syntax tree "
"that results\n"
"\t\t\t\tfrom it, we can extend it to include any operator we like.</p>"
msgstr ""
"<p>В предыдущих двух примерах мы расширили язык Java, введя оператор для "
"копирования файлов и\n"
"условный оператор \"если не\"(<em>unless</em>). Мы сделали это изменив "
"граматику абстрактного синтаксического\n"
"дерева, которую принимает компилятор Java. Естественно, мы не можем сделать "
"это стандартными средствами Java,\n"
"но мы можем легко это сделать в XML. Поскольку наш интерпретатор XML "
"анализирует полученное в результате\n"
"абстрактное синтаксическое дерево, мы можем расширить его, включив в него "
"любой понравившийся нам оператор.\n"
"</p>"

#: in/NatureOfLisp.htm:507
msgid ""
"<p>For complex operators this ability provides tremendous benefits. Can you "
"imagine\n"
"\t\t\t\twriting special operators for checking out source code, compiling "
"files, running\n"
"\t\t\t\tunit testing, sending email? Try to come up with some. If you're "
"dealing with a\n"
"\t\t\t\tspecialized problem (in our case it's building projects) these "
"operators can do\n"
"\t\t\t\twonders to decrease the amount of code you have to type and to "
"increase clarity\n"
"\t\t\t\tand code reuse. Interpreted XML makes this extremely easy to "
"accomplish because\n"
"\t\t\t\tit's a simple data file that stores hierarchical data. We do not "
"have this option\n"
"\t\t\t\tin Java because it's hierarchical structure is fixed (as you will "
"soon find out,\n"
"\t\t\t\twe do have this option in Lisp). Perhaps this is one of the reasons "
"why Ant is\n"
"\t\t\t\tso successful?</p>"
msgstr ""
"<p>Для сложных операторов эта возможность дает огромные преимущества. Можете "
"ли вы представить\n"
"написание специальных операторов для проверки исходного кода, компиляции "
"файлов, запуска\n"
"модульного тестирования, отправки электронной почты? Попробуйте что-нибудь "
"придумать. \n"
"Если вы имеете дело со специализированной проблемой (в нашем случае это "
"построение прокетов) \n"
"эти операторы могут творить чудеса, чтобы уменьшить количество кода, который "
"вы\n"
"должны ввести, и увеличивают ясность и повторное использование кода. "
"Интепретируемый XML\n"
"делай это чрезвычайно легким для выполнения, потому что это простой файл "
"данных, который\n"
"хранит иерархические данные. У нас нет такой возможности в Java, потому что "
"её иерархческая\n"
"структура ограничена (как вы скоро узнаете, у нас есть такая возможность/"
"опция в Лиспе). \n"
"Возможно, это одна из причин, почему  Ant так успешен?\n"
"</p>"

#: in/NatureOfLisp.htm:522
msgid ""
"<p>I urge you to take a look at recent evolution of Java and C# (especially "
"the\n"
"\t\t\t\trecently released specification for C# 3.0). The languages are being "
"evolved by\n"
"\t\t\t\tabstracting away commonly used functionality and adding it in the "
"form of\n"
"\t\t\t\toperators. New C# operators for built-in queries is one example. "
"This is\n"
"\t\t\t\taccomplished by relatively traditional means: language creators "
"modify the\n"
"\t\t\t\taccepted abstract syntax tree and add implementations of certain "
"features.\n"
"\t\t\t\tImagine the possibilities if the programmer could modify the "
"abstract syntax\n"
"\t\t\t\ttree himself! Whole new sub-languages could be built for specialized "
"domains (for\n"
"\t\t\t\texample a language for building projects, like Ant). Can you come up "
"with other\n"
"\t\t\t\texamples? Think about these concepts for a bit, but don't worry "
"about them too\n"
"\t\t\t\tmuch. We'll come back to these issues after introducing a few more "
"ideas. By\n"
"\t\t\t\tthen things will be a little more clear.</p>"
msgstr ""
"<p>Я призываю вас взглянуть на недавнюю эволюцию Java и C# (особенно недавно "
"выпущенную\n"
"спецификацию для C# 3.0). Языки развиваются путем абстрагирования часто "
"используемых\n"
"функций и добавления их в форме операторов. Новые операторы C# для "
"встроенных запросов -\n"
"это один из примеров. Это достигается относительно традиционными средствами: "
"создатели\n"
"языка модифицируют принимаемое абстрактное синтаксическое дерево и добавляют "
"реализации\n"
"определенных функций. Представьте себе возможности, если программист сам мог "
"бы изменять\n"
"абстрактное синтаксическое дерево! Полностю новые субязыки могут быть "
"созданы для \n"
"специализированных доменов(предметных областей)(например, язык для создания "
"проектов,\n"
"такой как Ant). Можете ли вы придумать другие примеры? Подумайте немного об "
"этих понятиях,\n"
"но не слишком переживайте о них. Мы вернемся к этим вопросам после того, как "
"представим\n"
"еще несколько идей. К тому времени все станет намного яснее.\n"
"</p>"

#: in/NatureOfLisp.htm:538
msgid ""
"\t\t\t\t<h2><a id=\"part_5\">Almost Lisp</a></h2>\n"
"\t\t\t\t<p class=\"first\">Let's forget about the operator business for the "
"moment and try to expand our\n"
"\t\t\t\thorizons beyond the constraints of Ant's design. I mentioned earlier "
"that Ant\n"
"\t\t\t\tcan be extended by writing conventional Java classes. Ant "
"interpreter then\n"
"\t\t\t\tattempts to match XML elements to appropriately named Java classes "
"and if the\n"
"\t\t\t\tmatch is found the task is executed. An interesting question begs to "
"be asked.\n"
"\t\t\t\tWhy not extend Ant in Ant itself? After all, core tasks contain a "
"lot of\n"
"\t\t\t\tconventional programming language constructs ('if' being a perfect "
"example). If\n"
"\t\t\t\tAnt provided constructs to develop tasks in Ant itself we'd reach a "
"higher\n"
"\t\t\t\tdegree of portability. We'd be dependent on a core set of tasks (a "
"standard\n"
"\t\t\t\tlibrary, if you will) and we wouldn't care if Java runtime is "
"present: the core\n"
"\t\t\t\tset could be implemented in anything. The rest of the tasks would be "
"built on\n"
"\t\t\t\ttop of the core using Ant-XML itself. Ant would then become a "
"generic,\n"
"\t\t\t\textensible, XML-based programming language. Consider the "
"possibilities:</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_5\">Почти Lisp</a></h2>\n"
"\t\t\t\t<p class=\"first\">Давайте на время забудем о построении операторов "
"и\n"
"попытаемся расширить наши горизонты за пределы ограничений дизайна Ant. "
"Ранее я упоминал, что Ant\n"
"можно расширить, написав обычные классы Java. Затем интерпретатор Ant "
"пытается сопоставить элементы\n"
"XML с соответствующими именами Java классов, и, если совпадение найдено, "
"задача выполняется.\n"
"Напрашивается интересный вопрос. Почему бы не расширить Ant в самом Ant? В "
"конце концов, основные\n"
"задачи содержат много традиционных конструкций языка программирования ('if' "
"- прекрасный пример).\n"
"Если бы Ant предоставил конструкции для разработки задач в самом Ant, мы бы  "
"достигли более высокой\n"
"степени переносимости. Мы бы зависели от основного набора задач (стандартной "
"библиотеки, если хотите)\n"
"и нам было бы все равно, присутствуют ли средства времени выполнения Java: "
"базовый набор может быть\n"
"реализован на любом языке, любой платформы. Остальные задачи будут построены "
"поверх ядра с использованием \n"
"самого Ant-XML. Тогда Ant станет общим расширяемым языком программирования "
"на основе XML. Рассмотрим\n"
"возможности:\n"
"</p>"

#: in/NatureOfLisp.htm:545
msgid ""
"<pre>&lt;task name=\"Test\"&gt;\n"
"    &lt;echo message=\"Hello World!\"/&gt;\n"
"&lt;/task&gt;\n"
"&lt;Test /&gt;\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:553
msgid ""
"<p>If ant supported the \"task\" construct, the example above would print "
"\"Hello\n"
"\t\t\t\tWorld!\". In fact, we could write a \"task\" task in Java and make "
"Ant able to\n"
"\t\t\t\textend itself using Ant-XML! Ant would then be able to build more "
"complicated\n"
"\t\t\t\tprimitives on top of simple ones, just like any other programming "
"language! This\n"
"\t\t\t\tis an example of \"XML\" based programming language we were talking "
"about in the\n"
"\t\t\t\tbeginning of this tutorial. Not very useful (can you tell why?) but "
"pretty damn\n"
"\t\t\t\tcool.</p>"
msgstr ""
"<p>\n"
"Если ant поддерживает конструкцию \"task\", в приведенном выше примере будет "
"напечатано \n"
"\"Hello World!\". Фактически, мы могли бы написать задачу(\"task\") на  Java "
"и сделать Ant\n"
"способным расширять себя, используя Ant-XML! Тогда Ant сможет создавать "
"более сложные\n"
"примитивы поверх простых, как и любой язык программирования! Это прмер языка "
"программирования\n"
"на основе \"XML\", о котором мы говорили в начале этого урока. Не очень "
"полезно (вы можете\n"
"сказать почему?), но чертовски круто.\n"
"</p>"

#: in/NatureOfLisp.htm:560
msgid ""
"<p>By the way, take a look at our 'Test' task once again. Congratulations. "
"You're\n"
"\t\t\t\tlooking at Lisp code. What on Earth am I talking about? It doesn't "
"look anything\n"
"\t\t\t\tlike Lisp? Don't worry, we'll fix that in a bit. Confused? Good. "
"Let's clear it\n"
"\t\t\t\tall up!</p>"
msgstr ""
"<p>Кстати, еще раз взгляните на нашу задачу 'Test'.  Поздравляю! Вы\n"
"смотрите на код Лисп! О чем я говорю? Это не похоже на Лисп? Не волнуйтесь,\n"
"мы это немного исправим. Смущены? Хорошо. Давайте все проясним!</p>"

#: in/NatureOfLisp.htm:571
msgid ""
"\t\t\t\t<h2><a id=\"part_6\">A Better XML</a></h2>\n"
"\t\t\t\t<p class=\"first\">I mentioned in the previous section that self-"
"extending Ant wouldn't be very\n"
"\t\t\t\tuseful. The reason for that is XML's verbosity. It's not too bad for "
"data files\n"
"\t\t\t\tbut the moment you try writing reasonably complex code the amount of "
"typing you\n"
"\t\t\t\thave to do quickly starts to get in the way and progresses to "
"becoming unusable\n"
"\t\t\t\tfor any real project. Have you ever tried writing Ant build scripts? "
"I have, and\n"
"\t\t\t\tonce they get complex enough having to do it in XML becomes really "
"annoying.\n"
"\t\t\t\tImagine having to type almost everything in Java twice because you "
"have to close\n"
"\t\t\t\tevery element. Wouldn't that drive you nuts?</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_6\">Лучший XML</a></h2>\n"
"\t\t\t\t<p class=\"first\">В предыдущем разделе я упомянул, что "
"саморасширяющийся\n"
"Ant не будет достаточно полезен. Причиной этого является многословие XML. Он "
"не так уж плох для файлов\n"
"данных, но в тот момент, когда вы попытаетесь написать достаточно сложный "
"код, количество набираемого\n"
"вами текста быстро начинает мешать и становиться непригодным для "
"использования в любом реальном\n"
"проекте. Вы когда-нибудь пытались написать сценарий сборки на Ant? Я да, и "
"как только он становится\n"
"достаточно сложным, необходимость делать это в  XML становится действительно "
"раздражающей.\n"
"Представьте, что вам нужно вводить почти все в Java дважды! Потому что вы "
"должны закрыть каждый\n"
"элемент. Разве это не сводит вас с ума?\n"
"</p>"

#: in/NatureOfLisp.htm:582
msgid ""
"<p>The solution to this problem involves using a less verbose alternative to "
"XML.\n"
"\t\t\t\tRemember, XML is just a format for representing hierarchical data. "
"We don't have\n"
"\t\t\t\tto use XML's angle brackets to serialize trees. We could come up "
"with many other\n"
"\t\t\t\tformats. One such format (incidentally, the one Lisp uses) is called "
"an\n"
"\t\t\t\ts-expression. S-expressions accomplish the same goals as XML. "
"They're just a lot\n"
"\t\t\t\tless verbose, which makes them much better suited for typing code. I "
"will\n"
"\t\t\t\texplain s-expressions in a little while, but before I do I have to "
"clear up a\n"
"\t\t\t\tfew things about XML. Let's consider our XML example for copying "
"files:</p>"
msgstr ""
"<p>Решение этой проблемы включает использование менее подробной альтернативы "
"XML.\n"
"Помните, что XML это просто формат данных для представления иерархических "
"данных.\n"
"Нам не нужно использовать угловые скобки XML для сериализации деревьев. Мы "
"могли\n"
"бы придумать много других форматов. Один из таких форматов (кстати, тот "
"который\n"
"использует Лисп) называется s-выражение(s-expression). S-выражения достигают "
"тех\n"
"же целей, что и XML. Они намного менее многословны, что делает их намного "
"лучше\n"
"подходящими для ввода кода. Я объясню s-выражения через некоторое время, но "
"прежде\n"
"чем я это сделаю, я должен разобраться с XML. Давайте рассмотрим наш пример "
"XML\n"
"для копирования файлов:\n"
"</p>"

#: in/NatureOfLisp.htm:588
msgctxt "in/NatureOfLisp.htm:588"
msgid ""
"<pre>&lt;copy todir=\"../new/dir\"&gt;\n"
"    &lt;fileset dir=\"src_dir\"/&gt;\n"
"&lt;/copy&gt;\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:598
msgid ""
"<p>Think of what the parse tree of this snippet would look like in memory. "
"We'd\n"
"\t\t\t\thave a 'copy' node that contains a fileset node. But what about "
"attributes? How\n"
"\t\t\t\tdo they fit into our picture? If you've ever used XML to describe "
"data and\n"
"\t\t\t\twondered whether you should use an element or an attribute, you're "
"not alone.\n"
"\t\t\t\tNobody can really figure this out and doing it right tends to be "
"black magic\n"
"\t\t\t\trather than science. The reason for that is that attributes are "
"really subsets\n"
"\t\t\t\tof elements. Anything attributes can do, elements can do as well. "
"The reason\n"
"\t\t\t\tattributes were introduced is to curb XML's verbosity. Take a look "
"at another\n"
"\t\t\t\tversion of our 'copy' snippet:</p>"
msgstr ""
"<p>Подумайте, как будет выглядеть дерево разбора этого фрагмента в памяти. У "
"нас будет узел\n"
"'copy', который содержит набор файлов. Но как насчет атрибутов? Как они "
"вписываются в нашу\n"
"картину? Если вы когда-либо использовали XML для описания данных и "
"задавались вопросом,\n"
"следует использовать элемент или атрубут, вы не одиноки. Никто не может "
"понять это и сделать\n"
"это правильно. Как правило это черная магия, а не наука. Причина в том, что "
"атрибуты\n"
"в действительности являются подмножеством элементов. Все что могут сделать "
"атрибуты, \n"
"могут сделать и элементы. Причина, по которой были введены атрибуты, "
"заключается в попытке\n"
"обуздать многословность XML. Взгляните на другую версию нашего фрагмента "
"'copy':</p>"

#: in/NatureOfLisp.htm:607
msgid ""
"<pre>&lt;copy&gt;\n"
"    &lt;todir&gt;../new/dir&lt;/todir&gt;\n"
"    &lt;fileset&gt;\n"
"        &lt;dir&gt;src_dir&lt;/dir&gt;\n"
"    &lt;/fileset&gt;\n"
"&lt;/copy&gt;\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:611
msgid ""
"<p>The two snippets hold exactly the same information. However, we use "
"attributes\n"
"\t\t\t\tto avoid typing the same thing more than once. Imagine if attributes "
"weren't\n"
"\t\t\t\tpart of XML specification. Writing anything in XML would drive us "
"nuts!</p>"
msgstr ""
"<p>Два фрагмента содержат одинаковую информацию. Однако мы используем "
"атрибуты, \n"
"чтобы не вводить одну и туже вещь более одного раза. Представьте, что "
"атрибуты\n"
"не являются частью спецификации XML. Написание чего-либо на XML сведет нас с "
"ума!\n"
"</p>"

#: in/NatureOfLisp.htm:619
msgid ""
"<p>Now that we got attributes out of the way, let's look at s-expressions. "
"The\n"
"\t\t\t\treason we took this detour is that s-expressions do not have "
"attributes. Because\n"
"\t\t\t\tthey're a lot less verbose, attributes are simply unnecessary. This "
"is one thing\n"
"\t\t\t\twe need to keep in mind when transforming XML to s-expressions. "
"Let's take a\n"
"\t\t\t\tlook at an example. We could translate above snippet to s-"
"expressions like this:</p>"
msgstr ""
"<p>Теперь когда мы избавились от атрибутов, давайте посмотрим на  s-"
"выражения.\n"
"Причина, по которой мы сделали этот крюк, заключается в том, что s-"
"выражения \n"
"не имеют атрибутов. Поскольку они гораздо менее многословны, атрибуты "
"просто\n"
"не нужны. Это та вещь, которую мы должны иметь в виду при преобразовании "
"XML\n"
"в s-выражения. Давайте рассмотрим один пример. Мы могли бы преобразовать\n"
"приведенный выше фрагмент в s-выражения, подобные этим:</p>"

#: in/NatureOfLisp.htm:625
msgid ""
"<pre>(copy\n"
"    (todir \"../new/dir\")\n"
"    (fileset (dir \"src_dir\")))\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:638
msgid ""
"<p>Take a good look at this representation. What's different? Angle brackets "
"seem\n"
"\t\t\t\tto be replaced by parentheses. Instead of enclosing each element "
"into a pair of\n"
"\t\t\t\tparentheses and then closing each element with a \"(/element)\" we "
"simply skip the\n"
"\t\t\t\tsecond parenthesis in \"(element\" and proceed. The element is then "
"closed like\n"
"\t\t\t\tthis: \")\". That's it! The translation is natural and very simple. "
"It's also a\n"
"\t\t\t\tlot easier to type. Do parentheses blind first time users? Maybe, "
"but now that\n"
"\t\t\t\twe're understand the reasoning behind them they're a lot easier to "
"handle. At\n"
"\t\t\t\tthe very least they're better than arthritis inducing verbosity of "
"XML. After\n"
"\t\t\t\tyou get used to s-expressions writing code in them is not only "
"doable but very\n"
"\t\t\t\tpleasant. And they provide all the benefits of writing code in XML "
"(many of\n"
"\t\t\t\twhich we're yet to explore). Let's take a look at our 'task' code in "
"something\n"
"\t\t\t\tthat looks a lot more like lisp:</p>"
msgstr ""
"<p>Взгляните хорошенько на это представление. А в чем разница? Угловые "
"скобки, по-видимому\n"
"заменяются круглыми скобками. Вместо того чтобы заключать каждый элемент в "
"пару скобок\n"
"и затем закрывать каждый элемент с помощью \"(/element)\" мы просто "
"пропускаем вторую\n"
"скобку в  \"(element\" и продолжаем. Затем элемент закрывается следующим "
"образом: \")\". \n"
"Вот и все! Преобразование естественное и очень простое. Кроме того, его "
"гораздо\n"
"легче печатать. Ослепляют ли скобки в первый раз пользователей? Может быть, "
"но теперь\n"
"когда мы понимаем причины, стоящие за этим, с ними гораздо легче "
"справиться.\n"
"По крайней мере, они лучше, чем артрит, вызываемый многословием XML. После "
"того,\n"
"как вы привыкните к s-выражениям, написание кода на нем, становиться не "
"только выполнимо,\n"
"но и приятно. И они предоставляют все преимущества написания кода на XML "
"(многие из\n"
"которых нам еще предстоит изучить). Давайте посмотрим на код нашей задачи - "
"'task' в\n"
"чем-то он очень похож на lisp:</p>"

#: in/NatureOfLisp.htm:642
msgid ""
"<pre>(task (name \"Test\")\n"
"    (echo (message \"Hello World!\")))"
msgstr ""

#: in/NatureOfLisp.htm:645
msgid ""
"(Test)\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:650
msgid ""
"<p>S-expressions are called lists in Lisp lingo. Consider our 'task' element "
"above.\n"
"\t\t\t\tIf we rewrite it without a line break and with comas instead of "
"spaces it's\n"
"\t\t\t\tstarting to look surprisingly like a list of elements and other "
"lists (the formatting\n"
"\t\t\t\tis added to make it easier to see nested lists):</p>"
msgstr ""
"<p>S-выражения называются списками на языке Lisp. Рассмотрим наш элемент "
"задача-'task', приведнный выше.\n"
"Если мы перепишем его без разрыва строки и с разделителями(запятыми) вместо "
"пробелов, то он удивительно\n"
"будет похож на список элементов и другие списки (форматирование добавляется, "
"чтобы облегчить\n"
"просмотр вложенных списков):</p>"

#: in/NatureOfLisp.htm:654
msgid ""
"<pre><span class=\"list\">(task,</span> <span class=\"inner-list\">(name, "
"\"test\")</span>, <span class=\"inner-inner-list\">(echo,</span> <span class="
"\"inner-list\">(message, \"Hello World!\")</span><span class=\"inner-inner-"
"list\">)</span><span class=\"list\">)</span>\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:660
msgid ""
"<p>We could do the same with XML. Of course the line above isn't really a "
"list,\n"
"\t\t\t\tit's a tree, just like its XML-alternative. Don't let references to "
"lists\n"
"\t\t\t\tconfuse you, it's just that lists that contain other lists and trees "
"are\n"
"\t\t\t\teffectively the same thing. Lisp may stand for List Processing, but "
"it's really\n"
"\t\t\t\ttree processing - no different than processing XML nodes.</p>"
msgstr ""
"<p>Мы могли бы сделать тоже самое с XML. Конечно, приведенная выше строка на "
"самом деле \n"
"не список, а дерево, как и его XML-альтернатива. Не позволяйте ссылкам на "
"списки\n"
"сбивать вас с толку, просто списки, содержащие другие списки и деревья - "
"это\n"
"фактически одно и тоже. Lisp может быть и означает Обработка Списков(List "
"Processing),\n"
"но на самом деле это может быть и обработка деревьев - она ничем не "
"отличается от\n"
"обработки XML узлов.</p>"

#: in/NatureOfLisp.htm:668
msgid ""
"<p>Whew. After much rambling we finally got to something that looks like "
"Lisp (and\n"
"\t\t\t\tis Lisp, really). By now the mysterious Lisp parentheses as well as "
"some claims\n"
"\t\t\t\tmade by Lisp advocates should become more clear. But we still have a "
"lot of\n"
"\t\t\t\tground to cover. Ready? Let's move on!</p>"
msgstr ""
"<p>Вот, как то так. После долгих бессвязных разговоров мы наконец добрались "
"до\n"
"чего-то похожего на Lisp (и это на самом деле Lisp). К настоящему времени\n"
"загадочные круглые скобки Lisp, а также некоторые утверждения, сделанные\n"
"защитниками(пропагандистами) Lisp должны стать более ясными. Но у нас есть\n"
"еще много неизведанной территории, чтобы ее освоить. Вы готовы?\n"
"Давайте двигаться дальше!</p>"

#: in/NatureOfLisp.htm:680
msgid ""
"\t\t\t\t<h2><a id=\"part_7\">C Macros Reloaded</a></h2>\n"
"\t\t\t\t<p class=\"first\">By now you must be tired of all the XML talk. I'm "
"tired of it as well. It's time\n"
"\t\t\t\tto take a break from all the trees, s-expressions, and Ant business. "
"Instead,\n"
"\t\t\t\tlet's go back to every programmer's roots. It's time to talk about "
"C\n"
"\t\t\t\tpreprocessor. What's C got to do with anything, I hear you ask? "
"Well, we now\n"
"\t\t\t\tknow enough to get into metaprogramming and discuss code that writes "
"other code.\n"
"\t\t\t\tUnderstanding this tends to be hard since all tutorials discuss it "
"in terms of\n"
"\t\t\t\tlanguages that you don't know. But there is nothing hard about the "
"concept. I\n"
"\t\t\t\tbelieve that a metaprogramming discussion based on C will make the "
"whole thing\n"
"\t\t\t\tmuch easier to understand. So, let's see (pun intended).</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_7\">C Macros Перезагрузка</a></h2>\n"
"\t\t\t\t<p class=\"first\">Теперь вы, должно быть, устали от всех этих\n"
"разговоров о XML. Мне это тоже надоело. Пришло время отдохнуть от всех этих "
"деревьев,\n"
"s-выражений, и занятий с Ant. Вместо этого давайте вернемся к корням каждого "
"программиста.\n"
"Пришло время поговорить о препроцессоре Си. А какое отношение Си имеет ко "
"всему этому,\n"
"спросите вы? Что ж, теперь мы знаем достаточно, чтобы занятся "
"метапрограммированием и\n"
"обсудить код, который пишет другой код. Понимание этого, как правило, "
"затруднено, так\n"
"как все учебники обсуждают его с точки зрения языков, которых вы не знаете. "
"Но в самой\n"
"концепции нет ничего сложного. Я полагаю, что обсуждение "
"метапрограммирования, основанного\n"
"на Си, сделает все это гораздо более понятным. Итак, давайте посмотрим (pun "
"intended).</p>"

#: in/NatureOfLisp.htm:693
msgid ""
"<p>Why would anyone want to write a program that writes programs? How can we "
"use\n"
"\t\t\t\tsomething like this in the real world? What on Earth is "
"metaprogramming, anyway?\n"
"\t\t\t\tYou already know all the answers, you just don't know it yet. In "
"order to unlock\n"
"\t\t\t\tthe hidden vault of divine knowledge let's consider a rather mundane "
"task of\n"
"\t\t\t\tsimple database access from code. We've all been there. Writing SQL "
"queries all\n"
"\t\t\t\tover the code to modify data within tables turns into repetitive "
"hell soon\n"
"\t\t\t\tenough. Even with the new C# 3.0 LINQ stuff this is a huge pain. "
"Writing a full\n"
"\t\t\t\tSQL query (albeit with a nice built in syntax) to get someone's name "
"or to\n"
"\t\t\t\tmodify someone's address isn't exactly a programmer's idea of "
"comfort. What do\n"
"\t\t\t\twe do to solve these problems? Enter data access layers.</p>"
msgstr ""
"<p>Зачем кому-то писать программу, которая пише программы? Как мы можем "
"использовать\n"
"что-то подобное в реальном мире? Что вообще такое, это метапрограммирование? "
"Вы уже\n"
"знаете все ответы, просто не осознаете их? Чтобы открыть скрытое хранилище "
"божественных\n"
"знаний, давайте рассмотрим приземленную задачу простого доступа к базе "
"данных из кода. \n"
"Мы все когда то этим занимались. Написание SQL запросов по всему коду для "
"изменения\n"
"данных в таблицах довольно скоро превращается в повторяющийся ад. Даже с "
"новым C# 3.0 \n"
"LINQ - это огромная боль. Написание полного SQL-запроса (хотя и с хорошим "
"встроенным\n"
"синтаксисом) для получения чьего-либо имени или изменения чьего-либо  адреса "
"- это\n"
"не совсем удобная идея для программиста. Что мы делаем, чтобы решить эти "
"проблемы? \n"
"Вводим слои доступа к данным.\n"
"</p>"

#: in/NatureOfLisp.htm:711
msgid ""
"<p>The idea is simple enough. You abstract database access (at least "
"trivial\n"
"\t\t\t\tqueries, anyway) by creating a set of classes that mirror the tables "
"in the\n"
"\t\t\t\tdatabase and use accessor methods to execute actual queries. This "
"simplifies\n"
"\t\t\t\tdevelopment tremendously - instead of writing SQL queries we make "
"simple method\n"
"\t\t\t\tcalls (or property assignments, depending on your language of "
"choice). Anyone\n"
"\t\t\t\twho has ever used even the simplest of data access layers knows how "
"much time it\n"
"\t\t\t\tcan save. Of course anyone who has ever written one knows how much "
"time it can\n"
"\t\t\t\tkill - writing a set of classes that mirror tables and convert "
"accessors to SQL\n"
"\t\t\t\tqueries takes a considerable chunk of time. This seems especially "
"silly since\n"
"\t\t\t\tmost of the work is manual: once you figure out the design and "
"develop a\n"
"\t\t\t\ttemplate for your typical data access class you don't need to do any "
"thinking.\n"
"\t\t\t\tYou just write code based on the same template over and over and "
"over and over\n"
"\t\t\t\tagain. Many people figured out that there is a better way - there "
"are plenty of\n"
"\t\t\t\ttools that connect to the database, grab the schema, and write code "
"for you based\n"
"\t\t\t\ton a predefined (or a custom) template.</p>"
msgstr ""
"<p>Идея достаточно проста. Вы абстрагируете доступ к базе данных (по крайней "
"мере,\n"
"тривиальные запросы), создавая набор классов, которые отражают таблицы в "
"базе данных\n"
"и используют методы доступа доступа(accessor) для выполнения реальных "
"запросов.\n"
"Это чрезвычайно упрощает разработку, вместо написания SQL-запросов мы делаем "
"простые\n"
"вызовы методов (или присваиваем свойства, в зависимости от выбранного вами "
"языка). \n"
"Любой, кто когда-либо использовал даже самые простые слои доступа к базам "
"данных,\n"
"знает, сколько времени это может сэкономить. Конечно, любой, кто когда-либо "
"писал,\n"
"знает, сколько времени он может убить: написание набора классов, которые "
"отражают\n"
"таблицы и конвертируют методы доступа(accessor) в SQL-запросы, занимает "
"значительный\n"
"кусок времени. Это кажется особенно глупым, поскольку большая часть работы "
"выполняется\n"
"в ручную: как только вы определитесь с дизайном и разработаете шаблон для "
"вашего\n"
"типичного класса доступа к данным, вам не нужно будет думать. Вы просто "
"пишете код на\n"
"основе одного и того же шаблона снова и снова, снова и снова. Многи люди "
"поняли,\n"
"что есть лучший способ - есть множество инструментов, которые подключаются к "
"базе\n"
"данных, захватывают схему, и пишут код для вас на основе "
"предопределенного(или \n"
"пользовательского) шаблона.\n"
"</p>"

#: in/NatureOfLisp.htm:725
msgid ""
"<p>Anyone who has ever used such a tool knows what an amazing time saver it "
"can be.\n"
"\t\t\t\tIn a few clicks you connect the tool to the database, get it to "
"generate the\n"
"\t\t\t\tdata access layer source code, add the files to your project and "
"voilÃ  - ten\n"
"\t\t\t\tminutes worth of work do a better job than hundreds of man-hours "
"that were\n"
"\t\t\t\trequired previously. What happens if your database schema changes? "
"Well, you\n"
"\t\t\t\tjust have to go through this short process again. Of course some of "
"the best\n"
"\t\t\t\ttools let you automate this - you simply add them as a part of your "
"build step\n"
"\t\t\t\tand every time you compile your project everything is done for you\n"
"\t\t\t\tautomatically. This is perfect! You barely have to do anything at "
"all. If the\n"
"\t\t\t\tschema ever changes your data access layer code updates "
"automatically at compile\n"
"\t\t\t\ttime and any obsolete access in your code will result in compiler "
"errors!</p>"
msgstr ""
"<p>Любой, кто когда либо пользовался таким инструментом, знает, что это "
"может быть\n"
"удивительная экономия времени. В несколько кликов вы подключаете инструмент "
"к \n"
"базе данных, заставляете его генерировать исходный код слоя доступа к "
"данным,\n"
"добавляете файлы в свой проект и вуаля - десять минут работы делают работу "
"лучше,\n"
"чем сотни человеко-часов, которые требовались ранее. Что произойдет, если "
"схема\n"
"вашей базы данных изменится? Ну вам просто нужно пройти через этот короткий "
"процесс\n"
"еще раз. Конечно, некотоыре из лучших инструментов позволяют вам "
"автоматизировать это\n"
"- вы просто добавляете их как часть вашего шага сборки, и каждый раз, когда "
"вы\n"
"компилируете свой проект, все делается автоматически. Это же прекрасно!\n"
"Теперь вообще почти ничего не нужно делать. Если схема когда либо изменит "
"ваш код\n"
"слоя доступа к данным автоматически обновляется во время компиляции и любой\n"
"устаревший доступ в вашем коде приведет к ошибкам компиляции!</p>"

#: in/NatureOfLisp.htm:736
msgid ""
"<p>Data access layers are one good example, but there are plenty of others. "
"From\n"
"\t\t\t\tboilerplate GUI code, to web code, to COM and CORBA stubs, to MFC "
"and ATL, -\n"
"\t\t\t\tthere are plenty of examples where the same code is written over and "
"over again.\n"
"\t\t\t\tSince writing this code is a task that can be automated completely "
"and a\n"
"\t\t\t\tprogrammer's time is far more expensive than CPU time, plenty of "
"tools have been\n"
"\t\t\t\tcreated that generate this boilerplate code automatically. What are "
"these tools,\n"
"\t\t\t\texactly? Well, they are programs that write programs. They perform a "
"simple task\n"
"\t\t\t\tthat has a mysterious name of metaprogramming. That's all there is "
"to it.</p>"
msgstr ""
"<p>Слои доступа к данным - это один хороший пример, но есть и много других. "
"От\n"
"стандартного кода GUI, до веб кода, заглушек COM и CORBA,  MFC и ATL, - "
"существует\n"
"множество примеров, когда один и тот же код пишется снова и снова. "
"Поскольку\n"
"написание этого кода является задачей, которую можно полностью "
"автоматизировать, \n"
"а время программиста на много дороже, чем время процессора, было создано "
"множество\n"
"инструментов, которые автоматические генерируют этот шаблонный код. "
"Собственно говоря,\n"
"что это за инструменты? Ну, это программы, которые пишут программы. Они "
"выполняют\n"
"простую задачу, имеющую загадочное название - метапрограммирование. Вот и "
"все,\n"
"что нужно сделать.\n"
"</p>"

#: in/NatureOfLisp.htm:750
msgid ""
"<p>We could create and use such tools in millions of scenarios but more "
"often than\n"
"\t\t\t\tnot we don't. What it boils down to is a subconscious calculation - "
"is it worth it\n"
"\t\t\t\tfor me to create a separate project, write a whole tool to generate "
"something,\n"
"\t\t\t\tand then use it, if I only have to write these very similar pieces "
"about seven\n"
"\t\t\t\ttimes? Of course not. Data access layers and COM stubs are written "
"hundreds,\n"
"\t\t\t\tthousands of times. This is why there are tools for them. For "
"similar pieces of\n"
"\t\t\t\tcode that repeat only a few times, or even a few dozen times, "
"writing code\n"
"\t\t\t\tgeneration tools isn't even considered. The trouble to create such a "
"tool more\n"
"\t\t\t\toften than not far outweighs the benefit of using one. If only "
"creating such\n"
"\t\t\t\ttools was much easier, we could use them more often, and perhaps "
"save many hours\n"
"\t\t\t\tof our time. Let's see if we can accomplish this in a reasonable "
"manner.</p>"
msgstr ""
"<p>Мы могли бы создать и использовать такие инструменты в милионах "
"сценариев, но чаще всего мы этого\n"
"не делаем. Это сводиться к подсознательному расчету - стоит ли мне создавать "
"отдельный проект,\n"
"писать целый инструмент для создания чего-то, а затем использовать его, если "
"мне нужно только написать\n"
"эти очень похожие куски примерно семь раз? Кончено же, НЕТ! Слои доступа к "
"данным и заглушки COM пишутся\n"
"сотни и тысячи раз. Вот почему для них существуют инструменты. Для подобных "
"фрагментов кода, которые \n"
"повторяются только несколько раз или даже несколько десятков раз, написание "
"инструментов генерации\n"
"кода даже не рассматривается. Трудность создания такого инструмента чаще "
"всего намного перевешивает\n"
"пользу от его использования. Если бы только создание таких инструментов было "
"намного проще, мы могли\n"
"бы использовать их чаще и, возможно, сэкономить много часов нашего времени. "
"Давайте посмотрим,\n"
"сможем ли мы сделать это разумным образом.\n"
"</p>"

#: in/NatureOfLisp.htm:757
msgid ""
"<p>Surprisingly C preprocessor comes to the rescue. We've all used it in C "
"and C++.\n"
"\t\t\t\tOn occasion we all wish Java had it. We use it to execute simple "
"instructions\n"
"\t\t\t\tat compile time to make small changes to our code (like selectively "
"removing\n"
"\t\t\t\tdebug statements). Let's look at a quick example:</p>"
msgstr ""
"<p>Удивительно, но препроцессор Си приходит на помощь. Мы все использовали "
"его в Си и Си++.\n"
"Иногда нам всем хотелось бы, чтобы на и Java был такой же. Мы используем его "
"для выполнения\n"
"простых инструкций во время компиляции, чтобы внести небольшие изменения в "
"наш код(например,\n"
"выборочное удаление операторов отладки). Давайте посмотрим на быстрый "
"пример:\n"
"</p>"

#: in/NatureOfLisp.htm:761
msgid ""
"<pre>#define triple(X)    X + X + X\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:771
msgid ""
"<p>What does this line do? It's a simple instruction written in the "
"preprocessor\n"
"\t\t\t\tlanguage that instructs it to replace all instances of "
"<em>triple(X)</em> with <em>X + X +\n"
"\t\t\t\tX</em>. For example all instances of '<em>triple(5)</em>' will be "
"replaced with '<em>5 + 5 + 5</em>'\n"
"\t\t\t\tand the resulting code will be compiled by the C compiler. We're "
"really doing a\n"
"\t\t\t\tvery primitive version of code generation here. If only C "
"preprocessor was a\n"
"\t\t\t\tlittle more powerful and included ways to connect to the database "
"and a few more\n"
"\t\t\t\tsimple constructs, we could use it to develop our data access layer "
"right there,\n"
"\t\t\t\tfrom within our program! Consider the following example that uses an "
"imaginary\n"
"\t\t\t\textension of the C preprocessor:</p>"
msgstr ""
"<p>Что делает эта строка? Эта простая инструкция, написанная на языке "
"препроцессора, которая\n"
"инструктирует его заменить все экземпляры <em>triple(X)</em> на <em>X + X + "
"X</em>. Например,\n"
"все экземпляры '<em>triple(5)</em>' будут заменены на '<em>5 + 5 + 5</em>' и "
"полученный код\n"
"будет скомпилирован компилятором Си. Здесь, мы действительно делаем очень "
"примитивную версию \n"
"генереации кода. Если бы только препроцессор Си был немного более мощным и "
"включал бы способы\n"
"подключения к базам данных и несколько более простых конструкций, мы могли "
"бы использовать его\n"
"для разработки нашего слоя доступа к данным прямо из нашей программы! "
"Рассмотрим следующий \n"
"пример, в котором используется воображаемое расширение препроцессора Си:</p>"

#: in/NatureOfLisp.htm:781
msgid ""
"<pre>#get-db-schema(\"127.0.0.1, un, pwd\");\n"
"#iterate-through-tables\n"
"#for-each-table\n"
"    class #table-name\n"
"    {\n"
"    };\n"
"#end-for-each\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:798
msgid ""
"<p>We've just connected to the database schema, iterated through all the "
"tables,\n"
"\t\t\t\tand created an empty class for each. All in a couple of lines right "
"within our\n"
"\t\t\t\tsource code! Now every time we recompile the file where above code "
"appears we'll\n"
"\t\t\t\tget a freshly built set of classes that automatically update based "
"on the\n"
"\t\t\t\tschema. With a little imagination you can see how we could build a "
"full data\n"
"\t\t\t\taccess layer straight from within our program, without the use of "
"any external\n"
"\t\t\t\ttools! Of course this has a certain disadvantage (aside from the "
"fact that such\n"
"\t\t\t\tan advanced version of C preprocessor doesn't exist) - we'd have to "
"learn a\n"
"\t\t\t\twhole new \"compile-time language\" to do this sort of work. For "
"complex code\n"
"\t\t\t\tgeneration this language would have to be very complex as well, it "
"would have to\n"
"\t\t\t\tsupport many libraries and language constructs. For example, if our "
"generated\n"
"\t\t\t\tcode depended on some file located at some ftp server the "
"preprocessor would\n"
"\t\t\t\thave to be able to connect to ftp. It's a shame to create and learn "
"a new\n"
"\t\t\t\tlanguage just to do this. Especially since there are so many nice "
"languages\n"
"\t\t\t\talready out there. Of course if we add a little creativity we can "
"easily avoid\n"
"\t\t\t\tthis pitfall.</p>"
msgstr ""
"<p>Мы только что подключились к схеме базы данных, перебрали все таблицы и "
"создали\n"
"пустой класс для каждой из них. И все это в паре строк прямо в нашем "
"исходном коде!\n"
"Теперь каждый раз, когда мы перекомпилируем файл, в котором появляется "
"приведенный\n"
"выше код, мы получим новый набор классов, которые автоматически обновляются "
"на\n"
"основе схемы БД. При небольшом воображении вы можете увидеть, как могли бы "
"построить\n"
"полный слой доступа к данным прямо из нашей программы, без использования "
"каких-либо\n"
"внешних инструментов! Конечно, он имеет определенный недостаток (помимо "
"того, что\n"
"такой продвинутой версии препроцессора Си не существует) - нам пришлось бы "
"выучить\n"
"совершенно новый \"язык времени компиляции\", чтобы выполнить такую работу. "
"Для создания\n"
"сложного кода этот язык тоже должен быть очень сложным, он должен "
"поддерживать множество\n"
"библиотек и языковых конструкций. Например, если бы наш сгенерированный код "
"зависел бы\n"
"от какого-то файла, расположенного на каком-то ftp серевер, препроцессор "
"должен был бы\n"
"иметь возможность подключиться к  ftp. Позорно создавать и изучать новый "
"язык только для\n"
"того, чтобы сделать это. Тем более, что там уже есть так много хороших "
"языков. Конечно,\n"
"если мы добавим немного смекалки, мы легко сможем избежать этой ловушки.\n"
"</p>"

#: in/NatureOfLisp.htm:804
msgid ""
"<p>Why not replace the preprocessor language with C/C++ itself? We'd have "
"full\n"
"\t\t\t\tpower of the language at compile time and we'd only need to learn a "
"few simple\n"
"\t\t\t\tdirectives to differentiate between compile time and runtime code!</"
"p>"
msgstr ""
"<p>Почему бы не заменить язык препроцессора на сам Си/Си++? Мы будем "
"обладать всей мощью\n"
"языка во время компиляции, и нам нужно будет выучить несколько простых "
"директив,\n"
"чтобы различать время компиляции и код времени выполнения!</p>"

#: in/NatureOfLisp.htm:815
msgid ""
"<pre>&lt;%\n"
"    cout &lt;&lt; \"Enter a number: \";\n"
"    cin &gt;&gt; n;\n"
"%&gt;\n"
"for(int i = 0; i &lt; &lt;%= n %&gt;; i++)\n"
"{\n"
"    cout &lt;&lt; \"hello\" &lt;&lt; endl;\n"
"}\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:824
msgid ""
"<p>Can you see what happens here? Everything that's between &lt;% and %&gt; "
"tags\n"
"\t\t\t\truns when the program is compiled. Anything outside of these tags is "
"normal\n"
"\t\t\t\tcode. In the example above you'd start compiling your program in the "
"development\n"
"\t\t\t\tenvironment. The code between the tags would be compiled and then "
"ran. You'd get\n"
"\t\t\t\ta prompt to enter a number. You'd enter one and it would be placed "
"inside the\n"
"\t\t\t\tfor loop. The for loop would then be compiled as usual and you'd be "
"able to\n"
"\t\t\t\texecute it. For example, if you'd enter 5 during the compilation of "
"your\n"
"\t\t\t\tprogram, the resulting code would look like this:</p>"
msgstr ""
"<p>Можете ли вы увидеть, что здесь происходит? Все что находиться между "
"тегами &lt;% и %&gt;\n"
"запускается при компиляции программы. Все что находится за пределами этих "
"тегов, является\n"
"обычным кодом. В приведенном выше примере вы начнете компилировать свою "
"программу в\n"
"среде разработки. Код между тегами будет скомпилирован и затем запущен. Вы "
"получите\n"
"приглашение ввести номер. Вы введете номер(например один) и он будет помещен "
"в цикл for.\n"
"Затем цикл for будет скомпилирован как обычно, и вы сможете его выполнить. "
"Например,\n"
"если бы вы ввели 5 во время компиляции вашей программы, полученный код "
"выглядел бы\n"
"следующим образом:</p>"

#: in/NatureOfLisp.htm:831
msgid ""
"<pre>for(int i = 0; i &lt; 5; i++)\n"
"{\n"
"    cout &lt;&lt; \"hello\" &lt;&lt; endl;\n"
"}\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:841
msgid ""
"<p>Simple and effective. No need for a special preprocessor language. We get "
"full\n"
"\t\t\t\tpower of our host language (in this case C/C++) at compile time. We "
"could easily\n"
"\t\t\t\tconnect to a database and generate our data access layer source code "
"at compile\n"
"\t\t\t\ttime in the same way JSP or ASP generate HTML! Creating such tools "
"would also be\n"
"\t\t\t\ttremendously quick and simple. We'd never have to create new "
"projects with\n"
"\t\t\t\tspecialized GUIs. We could inline our tools right into our programs. "
"We wouldn't\n"
"\t\t\t\thave to worry about whether writing such tools is worth it because "
"writing them\n"
"\t\t\t\twould be so fast - we could save tremendous amounts of time by "
"creating simple\n"
"\t\t\t\tbits of code that do mundane code generation for us!</p>"
msgstr ""
"<p>Просто и эффективно. Нет необходимости в специальном языке препроцессора. "
"Мы получаем\n"
"полную мощность нашего основного языка (в данном случае C/C++) во время "
"компиляции. Мы\n"
"можем легко подключиться к базе данных и сгенерировать исходный код нашего "
"слоя доступа\n"
"к данным во время компиляции таким же образом как JSP или ASP генерируют "
"HTML! Создание\n"
"таких инструментов также было бы чрезвычайно быстрым и простым. Нам не нужно "
"беспокоиться\n"
"о том, стоит ли писать такие инструменты, потому что написание их было бы "
"очень быстрым - \n"
"мы могли бы сэкономить огромное количество времени, создавая простые "
"фрагменты кода,\n"
"которые выполняют за нас обычную генерацию кода!\n"
"</p>"

#: in/NatureOfLisp.htm:849
msgid ""
"\t\t\t\t<h2><a id=\"part_8\">Hello, Lisp!</a></h2>\n"
"\t\t\t\t<p class=\"first\">Everything we've learned about Lisp so far can be "
"summarized by a single\n"
"\t\t\t\tstatement: Lisp is executable XML with a friendlier syntax. We "
"haven't said a\n"
"\t\t\t\tsingle word about how Lisp actually operates. It's time to fill "
"this\n"
"\t\t\t\tgap<sup><a href=\"#note-blaise\">2</a></sup>.</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_8\">Привет, Lisp!</a></h2>\n"
"\t\t\t\t<p class=\"first\">Все, что мы узнали о Лиспе до сих пор,\n"
"можно обобщить одним утверждением: Lisp это исполняемый XML с блее "
"дружественным синтаксисом.\n"
"Мы не сказали ни слова о том, как на самом деле работает Лисп. Пришло время "
"заполнить этот\n"
"пробел<sup><a href=\"#note-blaise\">2</a></sup>.\n"
"</p>"

#: in/NatureOfLisp.htm:863
msgid ""
"<p>Lisp has a number of built in data types. Integers and strings, for "
"example,\n"
"\t\t\t\taren't much different from what you're used to. The meaning of "
"<em>71</em> or <em>\"hello\"</em> is\n"
"\t\t\t\troughly the same in Lisp as in C++ or Java. What is of more interest "
"to us are\n"
"\t\t\t\t<em>symbols</em>, <em>lists</em>, and <em>functions</em>. I will "
"spend the rest of this section describing\n"
"\t\t\t\tthese data types as well as how a Lisp environment compiles and "
"executes the\n"
"\t\t\t\tsource code you type into it (this is called <em>evaluation</em> in "
"Lisp lingo). Getting\n"
"\t\t\t\tthrough this section in one piece is important for understanding "
"true potential of\n"
"\t\t\t\tLisp's metaprogramming, the unity of code and data, and the notion "
"of domain\n"
"\t\t\t\tspecific languages. Don't think of this section as a chore though, "
"I'll try to\n"
"\t\t\t\tmake it fun and accessible. Hopefully you can pick up a few "
"interesting ideas on\n"
"\t\t\t\tthe way. Ok. Let's start with Lisp's symbols.</p>"
msgstr ""
"<p>Lisp имеет ряд встроенных типов данных. Например, целые(Integers) и "
"строки(string)\n"
"мало чем отличающиеся от того, к чему вы привыкли. Значение <em>71</em> или "
"<em>\"hello\"</em> \n"
"примерно такое же, как в Си++ или Java. Для нас более интересны "
"символы(<em>symbols</em>),\n"
"списки(<em>lists</em>) и функции(<em>functions</em>). Я проведу оставшуюся "
"часть этого раздела,\n"
"описывая эти типы данных, а также то, как среда Лисп компилирует и выполняет "
"исходный код,\n"
"который вы вводите в неё (это называется оценкой(<em>evaluation</em>) на "
"языке Лисп(прим. переводчика:\n"
"я все же обычно перевожу это как выполнение, так как мне это более "
"привычно). Прохождение этого\n"
"раздела целиком важно для понимания истинного потенциала "
"метапрограммирования Лисп.,\n"
"единства кода и данных, а также понимания предметно(доменно)-ориентированных "
"языков(domain\n"
"specific language). Не думайте об этом разделе как о рутинной работе, хотя я "
"постараюсь сделать\n"
"его веселым и доступным. Надеюсь, вы сможете подобрать несколько интересных "
"идей по пути. Ну что ж,\n"
"давайте начнем с символов Лисп.\n"
"</p>"

#: in/NatureOfLisp.htm:876
msgid ""
"<p>A symbol in Lisp is roughly equivalent to C++ or Java's notion of an "
"identifier.\n"
"\t\t\t\tIt's a name you can use to access a variable (like <em>currentTime</"
"em>, <em>arrayCount</em>, <em>n</em>,\n"
"\t\t\t\tetc.) The difference is that a symbol in Lisp is a lot more liberal "
"than its\n"
"\t\t\t\tmainstream identifier alternative. In C++ or Java you're limited to\n"
"\t\t\t\talphanumeric characters and an underscore. In Lisp, you are not. For "
"example <em>+</em>\n"
"\t\t\t\tis a valid symbol. So is <em>-</em>, <em>=</em>, <em>hello-world</"
"em>, <em>hello+world</em>, <em>*</em>, etc. (you can find\n"
"\t\t\t\tthe exact definition of valid Lisp symbols online). You can assign "
"to these\n"
"\t\t\t\tsymbols any data-type you like. Let's ignore Lisp syntax and use "
"pseudo-code for\n"
"\t\t\t\tnow. Assume that a function <em>set</em> assigns some value to a "
"symbol (like <em>=</em> does\n"
"\t\t\t\tin Java or C++). The following are all valid examples:</p>"
msgstr ""
"<p>Символ в Лиспе примерно эквивалентен понятию идентификатора в Си++ или "
"Java.\n"
"Это имя, которое вы можете использовать для доступа к переменной (например \n"
"<em>currentTime</em>, <em>arrayCount</em>, <em>n</em>, и т.д.). Разница в "
"том,\n"
"что символ в Лиспе намного более либерален, чем его альтернатива в основном\n"
"направлении программирования. В Си++ или Java вы ограничены буквенно-"
"цифровыми\n"
"знаками и знаком подчеркивания. В Лиспе, таких ограничений нет. Например: "
"<em>+</em>\n"
"является допустимым символом. То есть <em>-</em>, <em>=</em>, <em>hello-"
"world</em>, \n"
"<em>hello+world</em>, <em>*</em>, и т.д. (вы можете найти точное "
"определение\n"
"действительных символов в Лиспе в интернете). Вы можете назначить этим "
"символам\n"
"любой тип данных, который вам нравиться. Давайте проигнориуем синтаксис Лисп "
"и\n"
"пока воспользуемся псевдокодом. Предположим, что функция set присваивает "
"символу\n"
"какое-то значение(как это делает <em>=</em> в Java или C++). Ниже приведены "
"все\n"
"действительные примеры:\n"
"</p>"

#: in/NatureOfLisp.htm:885
msgid ""
"<pre>set(test, 5)            // symbol 'test' will equal an integer 5\n"
"set(=, 5)               // symbol '=' will equal an integer 5\n"
"set(test, \"hello\")      // symbol 'test' will equal a string \"hello\"\n"
"set(test, =)            // at this point symbol '=' is equal to 5\n"
"                        // therefore symbol 'test' will equal to 5\n"
"set(*, \"hello\")         // symbol '*' will equal a string \"hello\"\n"
"</pre>"
msgstr ""
"<pre>set(test, 5)       // символ 'test' будет равен целому 5\n"
"set(=, 5)               // символ '=' будет равен целому 5\n"
"set(test, \"hello\")      // символ 'test' будет равен строке \"hello\"\n"
"set(test, =)            // в этой точке символ '=' равен 5\n"
"                        // поэтому символ 'test' будет равен 5\n"
"set(*, \"hello\")         // символ '*' будет равен строке \"hello\"\n"
"</pre>"

#: in/NatureOfLisp.htm:894
msgid ""
"<p>At this point something must smell wrong. If we can assign strings and "
"integers\n"
"\t\t\t\tto symbols like <em>*</em>, how does Lisp do multiplication? After "
"all, <em>*</em> means\n"
"\t\t\t\tmultiply, right? The answer is pretty simple. Functions in Lisp "
"aren't special.\n"
"\t\t\t\tThere is a data-type, function, just like integer and string, that "
"you assign to\n"
"\t\t\t\tsymbols. A multiplication function is built into Lisp and is "
"assigned to a\n"
"\t\t\t\tsymbol <em>*</em>. You can reassign a different value to <em>*</em> "
"and you'd lose the\n"
"\t\t\t\tmultiplication function. Or you can store the value of the function "
"in some\n"
"\t\t\t\tother variable. Again, using pseudo-code:</p>"
msgstr ""
"<p>На данный момент это попахивает не очень хорошо. Если мы можем присвоить "
"строки и\n"
"числа таким символам как <em>*</em>, как тогда Лисп выполнить умножение? В "
"конце концов,\n"
"<em>*</em> означает умножение, верно? Ответ довольно прост. Функции в Лиспе "
"не особенные.\n"
"Существует тип данных фунция(function), такой же как целое(integer) и "
"строка(string), значения\n"
"этих типов вы присваиваете символам. Функция умножения встроена в Лисп и "
"присваивается символу <em>*</em>.\n"
"Вы можете переназначить другое значение <em>*</em> и потеряете функцию "
"умножения. Или вы можете\n"
"сохранить значение функции в другой переменной. Опять же используя "
"псевдокод:\n"
"(прим.переводчика: все вышесказанное относится к диалекту лиспа: Scheme, "
"современный ansi common\n"
"lisp имеет два пространства имен, одно для символов функций и второе для "
"символов переменных,\n"
"там тоже можно сделать нечто подобное, но только более сложным образом)\n"
"</p>"

#: in/NatureOfLisp.htm:907
msgid ""
"<pre>*(3, 4)                 // multiplies 3 by 4, resulting in 12\n"
"set(temp, *)            // symbol '*' is equal to the multiply function\n"
"                        // so temp will equal to the multiply function\n"
"set(*, 3)               // sets symbol '*' to equal to 3\n"
"*(3, 4)                 // error, symbol '*' no longer equals to a function\n"
"                        // it's equal to 3\n"
"temp(3, 4)              // temp equals to a multiply function\n"
"                        // so Lisp multiplies 3 by 4 resulting in 12\n"
"set(*, temp)            // symbol '*' equals multiply function again\n"
"*(3, 4)                 // multiplies 3 by 4, resulting in 12\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:909
msgid "<p>You can even do wacky stuff like reassigning plus to minus:</p>"
msgstr ""
"<p>Вы можете даже делать дурацкие вещи, такие как переназначение плюса на "
"минус:\n"
"</p>"

#: in/NatureOfLisp.htm:916
msgid ""
"<pre>set(+, -)               // the value of '-' is a built in minus "
"function\n"
"                        // so now symbol '+' equals to a minus function\n"
"+(5, 4)                 // since symbol '+' is equal to the minus function\n"
"                        // this results in 1\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:925
msgid ""
"<p>I've used functions quite liberally in these examples but I didn't "
"describe them\n"
"\t\t\t\tyet. A function in Lisp is just a data-type like an integer, a "
"string, or a\n"
"\t\t\t\tsymbol. A function doesn't have a notion of a name like in Java or C+"
"+. Instead, it\n"
"\t\t\t\tstands on its own. Effectively it is a pointer to a block of code "
"along with\n"
"\t\t\t\tsome information (like a number of parameters it accepts). You only "
"give the\n"
"\t\t\t\tfunction a name by assigning it to a symbol, just like you assign an "
"integer or\n"
"\t\t\t\ta string. You can create a function by using a built in function for "
"creating\n"
"\t\t\t\tfunctions, assigned to a symbol 'fn'. Using pseudo-code:</p>"
msgstr ""
"<p>В этих примерах я довольно свободно использовал функции, но пока не "
"описывал их.\n"
"Функция в Лиспе это просто тип данных, такой как целое число, строка или "
"символ.\n"
"Функция не имеет такого понятия как имя, подобное в Си++ или Java. Вместо "
"этого,\n"
"она стоит сама по себе. Фактически, это указатель на блок кода вместе с "
"некоторой\n"
"информацией(например, рядом параметров, которые она принимает). Только вы "
"даете\n"
"функции имя, назначая(присваивая) ее символу, точно так же, как вы "
"присваиваете\n"
"целое число или строку. Вы можете создать функцию используя встроенную "
"функцию\n"
"для создания функций, присвоенную символу 'fn'(прим. перводчика: вообщето "
"это lambda). \n"
"Использя псевдо-код:</p>"

#: in/NatureOfLisp.htm:932
msgid ""
"<pre>fn [a]\n"
"{\n"
"    return *(a, 2);\n"
"}\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:935
msgid ""
"<p>This returns a function that takes a single parameter named <em>'a'</em> "
"and doubles it.\n"
"\t\t\t\tNote that the function has no name but you can assign it to a symbol:"
"</p>"
msgstr ""
"<p>Эта конструкция возвращает функцию, котора принимает единственный "
"параметр \n"
"именумый <em>'a'</em> и удваивает его. Обратите внимание, что у функции нет\n"
"имени, но вы можте присвоить её символу:\n"
"</p>"

#: in/NatureOfLisp.htm:939
msgid ""
"<pre>set(times-two, fn [a] { return *(a, 2); })\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:941
msgid "<p>We can now call this function:</p>"
msgstr ""
"<p>Теперь мы можем вызвать эту функцию:\n"
"</p>"

#: in/NatureOfLisp.htm:945
msgid ""
"<pre>times-two(5)             // returns 10\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:951
msgid ""
"<p>Now that we went over symbols and functions, what about lists? Well, you "
"already\n"
"\t\t\t\tknow a lot about them. Lists are simply pieces of XML written in s-"
"expression\n"
"\t\t\t\tform. A list is specified by parentheses and contains Lisp data-"
"types (including\n"
"\t\t\t\tother lists) separated by a space. For example (this is real Lisp, "
"note that we\n"
"\t\t\t\tuse semicolons for comments now):</p>"
msgstr ""
"<p>Теперь, когда мы рассмотрели символы и функции, как на счет списков?\n"
"Ну, вы уже много знаете о них. Списки это просто фрагменты  XML записанные\n"
"в форме s-выражений. Список задается круглыми скобками и содержит типы "
"данных\n"
"Лисп (включая и другие списки), разделенные пробелами. Например (это\n"
"настоящий Лисп, обратите внимание, что теперь мы используем точку с "
"запятой,\n"
"для комментариев):\n"
"</p>"

#: in/NatureOfLisp.htm:963
msgid ""
"<pre>()                      ; an empty list\n"
"(1)                     ; a list with a single element, 1\n"
"(1 \"test\")              ; a list with two elements\n"
"                        ; an integer 1 and a string \"test\"\n"
"(test \"hello\")          ; a list with two elements\n"
"                        ; a symbol test and a string \"hello\"\n"
"(test (1 2) \"hello\")    ; a list with three elements, a symbol test\n"
"                        ; a list of two integers 1 and 2\n"
"                        ; and a string \"hello\"\n"
"</pre>"
msgstr ""
"<pre>()                      ; пустой списокan empty list\n"
"(1)                     ; список из одного элемента, 1\n"
"(1 \"test\")              ; a list with two elements\n"
"                        ; an integer 1 and a string \"test\"\n"
"(test \"hello\")          ; a list with two elements\n"
"                        ; a symbol test and a string \"hello\"\n"
"(test (1 2) \"hello\")    ; список с тремя элементами, символа test\n"
"                        ; списка двух целых 1 и 2\n"
"                        ; и строки \"hello\"\n"
"</pre>"

#: in/NatureOfLisp.htm:972
msgid ""
"<p>When a Lisp system encounters lists in the source code it acts exactly "
"like Ant\n"
"\t\t\t\tdoes when it encounters XML - it attempts to execute them. In fact, "
"Lisp source\n"
"\t\t\t\tcode is only specified using lists, just like Ant source code is "
"only specified\n"
"\t\t\t\tusing XML. Lisp executes lists in the following manner. The first "
"element of the\n"
"\t\t\t\tlist is treated as the name of a function. The rest of the elements "
"are treated\n"
"\t\t\t\tas functions parameters. If one of the parameters is another list it "
"is\n"
"\t\t\t\texecuted using the same principles and the result is passed as a "
"parameter to\n"
"\t\t\t\tthe original function. That's it. We can write real code now:</p>"
msgstr ""
"<p>Когда система Лисп сталкивается со списками в исходном коде, она "
"действует\n"
"точно так же, как  Ant, когда он сталкивается с XML - она пытается исполнить "
"их. \n"
"На самом деле исходный код Лисп и задается только с помощью списков, точно\n"
"также как исходный код Ant задается только с помощью использования XML. "
"Лисп\n"
"выполняет списки следующим образом. Первый элемент списка обрабатывается "
"как\n"
"имя функции. Остальные элементы рассматриваются как параметры функции. Если "
"один\n"
"из параметров является другим списком, то он выполняется по тем же "
"принципам,\n"
"и результат передается в качестве параметра исходной функции. Вот и все.\n"
"Теперь мы можем писать настоящий код:\n"
"</p>"

#: in/NatureOfLisp.htm:990
msgid ""
"<pre>(* 3 4)                 ; equivalent to pseudo-code *(3, 4).\n"
"                        ; Symbol '*' is a function\n"
"                        ; 3 and 4 are its parameters.\n"
"                        ; Returns 12.\n"
"(times-two 5)           ; returns 10\n"
"(3 4)                   ; error: 3 is not a function\n"
"(times-two)              ; error, times-two expects one parameter\n"
"(times-two 3 4)          ; error, times-two expects one parameter\n"
"(set + -)               ; sets symbol '+' to be equal to whatever symbol "
"'-'\n"
"                        ; equals to, which is a minus function\n"
"(+ 5 4)                 ; returns 1 since symbol '+' is now equal\n"
"                        ; to the minus function\n"
"(* 3 (* 2 2))           ; multiplies 3 by the second parameter\n"
"                        ; (which is a function call that returns 4).\n"
"                        ; Returns 12.\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:995
msgid ""
"<p>Note that so far every list we've specified was treated by a Lisp system "
"as\n"
"\t\t\t\tcode. But how can we treat a list as data? Again, imagine an Ant "
"task that\n"
"\t\t\t\taccepts XML as one of its parameters. In Lisp we do this using a "
"quote operator\n"
"\t\t\t\t<em>'</em> like so:</p>"
msgstr ""
"<p>Обратите внимание, что до сих пор каждый указанный нами список "
"обрабатывался\n"
"системой Лисп как код. Но как же мы можем рассматривать список как данные? "
"Опять же,\n"
"представьте себе задачу Ant, которая принимает XML в качестве одного из "
"своих\n"
"параметров. В лиспе мы делаем с помощью оператора quote или сокращенно\n"
"<em>'</em>, например так:</p>"

#: in/NatureOfLisp.htm:1002
msgid ""
"<pre>(set test '(1 2))       ; test is equal to a list of two integers, 1 "
"and 2\n"
"(set test (1 2))        ; error, 1 is not a function\n"
"(set test '(* 3 4))     ; sets test to a list of three elements,\n"
"                        ; a symbol *, an integer 3, and an integer 4\n"
"</pre>"
msgstr ""
"<pre>(set test '(1 2))         ; test is equal to a list of two integers, 1 "
"and 2\n"
"(set test (1 2))           ; error, 1 is not a function\n"
"(set test '(* 3 4))        ; sets test to a list of three elements,\n"
"(set test (quote (* 3 4))) ; a symbol *, an integer 3, and an integer 4, "
"длинная запись с оператором quote\n"
"</pre>"

#: in/NatureOfLisp.htm:1006
msgid ""
"<p>We can use a built in function <em>head</em> to return the first element "
"of the\n"
"\t\t\t\tlist, and a built in function <em>tail</em> to return the rest of "
"the list's\n"
"\t\t\t\telements:</p>"
msgstr ""
"<p>Мы можем использовать встроенную функцию <em>head</em> для возврата "
"первого\n"
"элемента списка, и встроенную функцию <em>tail</em> для возврата последнего\n"
"элемента списка:\n"
"</p>"

#: in/NatureOfLisp.htm:1015
msgid ""
"<pre>(head '(* 3 4))         ; returns a symbol '*'\n"
"(tail '(* 3 4))         ; returns a list (3 4)\n"
"(head (tail '( * 3 4))) ; (tail '(* 3 4)) returns a list (3 4)\n"
"                        ; and (head '(3 4)) returns 3.\n"
"(head test)             ; test was set to a list in previous example\n"
"                        ; returns a symbol '*'\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1021
msgid ""
"<p>You can think of built in Lisp functions as you think of Ant tasks. The "
"difference\n"
"\t\t\t\tis that we don't have to extend Lisp in another language (although "
"we can), we can\n"
"\t\t\t\textend it in Lisp itself as we did with the <em>times-two</em> "
"example. Lisp comes with a very\n"
"\t\t\t\tcompact set of built in functions - the necessary minimum. The rest "
"of the language\n"
"\t\t\t\tis implemented as a standard library in Lisp itself.</p>"
msgstr ""
"<p>Вы можете думать о встроенных функциях Лисп, как вы думаете о задачах в "
"Ant. \n"
"Разница в том, что нам не нужно расширять Лисп на другом языке (хотя и это "
"возмжно),\n"
"мы можем расширить его на самом Лиспе, как это была в примере с <em>times-"
"two</em>.\n"
"Лисп поставляется с очень компактным набором встроенных функций - "
"необходимым минимумом.\n"
"Остальная часть языка реализована как стандартная библиотека на самом "
"Лиспе.\n"
"</p>"

#: in/NatureOfLisp.htm:1031
msgid ""
"\t\t\t\t<h2><a id=\"part_9\">Lisp Macros</a></h2>\n"
"\t\t\t\t<p class=\"first\">So far we've looked at metaprogramming in terms "
"of a simple templating\n"
"\t\t\t\tengine similar to JSP. We've done code generation using simple "
"string\n"
"\t\t\t\tmanipulations. This is generally how most code generation tools go\n"
"\t\t\t\tabout doing this task. But we can do much better. To get on the\n"
"\t\t\t\tright track, let's start off with a question. How would we write a\n"
"\t\t\t\ttool that automatically generates Ant build scripts by looking at\n"
"\t\t\t\tsource files in the directory structure?</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_9\">Макросы Лисп</a></h2>\n"
"\t\t\t\t<p class=\"first\">До сих пор мы рассматривали метапрограммирование\n"
"с точки зрения простого шаблонизатора(templating engine), похожего на JSP. "
"Мы сделали\n"
"генерацию кода, используя простые манипуляции со строками. Как правило, "
"именно так\n"
"большинство инструментов генерации кода выполняют эту задачу. Но мы можем "
"сделать\n"
"намного лучше. Чтобы встать на правильный путь, давайте начнем с вопроса. "
"Как написать\n"
"инструмент, который автоматически генерирует сценарии сборки Ant, "
"просматривая\n"
"исходные файлы в структуре каталогов?\n"
"</p>"

#: in/NatureOfLisp.htm:1043
msgid ""
"<p>We could take the easy way out and generate Ant XML by manipulating\n"
"\t\t\t\tstrings. Of course a much more abstract, expressive and extensible "
"way\n"
"\t\t\t\tis to work with XML processing libraries to generate XML nodes\n"
"\t\t\t\tdirectly in memory. The nodes can then be serialized to strings\n"
"\t\t\t\tautomatically. Furthermore, our tool would be able to analyze and\n"
"\t\t\t\ttransform existing Ant build scripts by loading them and dealing "
"with\n"
"\t\t\t\tthe XML nodes directly. We would abstract ourselves from strings and "
"deal\n"
"\t\t\t\twith higher level concepts which let us get the job done faster and\n"
"\t\t\t\teasier.</p>"
msgstr ""
"<p>Мы могли бы пойти простым путем и сгенерировать Ant XML, манипулируя "
"строками.\n"
"Конечно, более абстрактный, выразительный и расширяемый способ - работать "
"с \n"
"библиотеками обработки  XML для генерации узлов XML непосредственно в "
"памяти.\n"
"Затем узлы могут быть автоматически сериализованы в строки. Кроме того, наш "
"инструмент\n"
"сможет анализировать и преобразовывать существующие сценарии сборки Ant "
"загружая их\n"
"и напрямую работая с узлами XML. Мы бы абстрагировались от строк и имели "
"дело с \n"
"концепциями более высокого уровня, которые позволяют выполнить работу "
"быстрее\n"
"и проще.\n"
"</p>"

#: in/NatureOfLisp.htm:1053
msgid ""
"<p>Of course we could write Ant tasks that allow dealing with XML\n"
"\t\t\t\ttransformations and write our generation tool in Ant itself. Or we\n"
"\t\t\t\tcould just use Lisp. As we saw earlier, a list is a built in Lisp\n"
"\t\t\t\tdata structure and Lisp has a number of facilities for processing "
"lists\n"
"\t\t\t\tquickly and effectively (<em>head</em> and <em>tail</em> being the "
"simplest ones). Additionally Lisp\n"
"\t\t\t\thas no semantic constraints - you can have your code (and data) "
"have\n"
"\t\t\t\tany structure you want.</p>"
msgstr ""
"<p>Конечно, мы могли бы написать задачи Ant, которые позволяют иметь\n"
"дело с преобразованиями XML, и написать наш инструмент генерации на\n"
"самом Ant. Или мы могли бы просто использовать Лисп. Как мы видели \n"
"ранее, список представляет собой встроенную структуру данных Лисп\n"
"и Лисп имеет ряд средств для быстрой и эффективной обработки списков\n"
"(простейшие из них это <em>head</em> и <em>tail</em>). Кроме того,\n"
"в Лиспе нет семантических ограничений - вы может иметь свой код \n"
"(и данные) любой структуры, по вашему желанию.\n"
"</p>"

#: in/NatureOfLisp.htm:1060
msgid ""
"<p>Metaprogramming in Lisp is done using a\n"
"\t\t\t\tconstruct called a \"macro\". Let's try to develop a set of macros "
"that\n"
"\t\t\t\ttransform data like, say, a to-do list (surprised?), into a language "
"for dealing with\n"
"\t\t\t\tto-do lists.</p>"
msgstr ""
"<p>\n"
"Метапрограммирование на Лиспе осуществляется с помощью конструкции, "
"называемой \"macro\". \n"
"Давайте попробуем разработать набор макросов, которые преобразовывают "
"данные, например\n"
"список дел (удивлены?), в язык для работы со списками дел.\n"
"</p>"

#: in/NatureOfLisp.htm:1064
msgid "<p>Let's recall our to-do list example. The XML looks like this:</p>"
msgstr "<p>Давайте вспомним наш пример списка дел. Его XML выглядит так:</p>"

#: in/NatureOfLisp.htm:1072
msgctxt "in/NatureOfLisp.htm:1072"
msgid ""
"<pre>&lt;todo name=\"housework\"&gt;\n"
"    &lt;item priority=\"high\"&gt;Clean the house.&lt;/item&gt;\n"
"    &lt;item priority=\"medium\"&gt;Wash the dishes.&lt;/item&gt;\n"
"    &lt;item priority=\"medium\"&gt;Buy more soap.&lt;/item&gt;\n"
"&lt;/todo&gt;\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1074
msgid "<p>The corresponding s-expression version looks like this:</p>"
msgstr "<p>Соответствующая версия s-выражения выглядит так:</p>"

#: in/NatureOfLisp.htm:1081
msgid ""
"<pre>(todo \"housework\"\n"
"    (item (priority high) \"Clean the house.\")\n"
"    (item (priority medium) \"Wash the dishes.\")\n"
"    (item (priority medium) \"Buy more soap.\"))\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1091
msgid ""
"<p>Suppose we're writing a to-do manager application. We keep our to-do\n"
"\t\t\t\titems serialized in a set of files and when the program starts up "
"we\n"
"\t\t\t\twant to read them and display them to the user. How would we do "
"this\n"
"\t\t\t\twith XML and some other language (say, Java)? We'd parse our XML "
"files\n"
"\t\t\t\twith the to-do lists using some XML parser, write the code that "
"walks\n"
"\t\t\t\tthe XML tree and converts it to a Java data structure (because "
"frankly,\n"
"\t\t\t\tprocessing DOM in Java is a pain in the neck), and then use\n"
"\t\t\t\tthis data structure to display the data. Now, how would we do the\n"
"\t\t\t\tsame thing in Lisp?</p>"
msgstr ""
"<p>Предположим, что мы пишем приложение для управления делами(to-do "
"manager).\n"
"Мы сохраним сериализацию наших дел в виде набора файлов и когда программа\n"
"запускается, мы хотим прочитать их и отобразить их пользователю. Как бы мы\n"
"сделали это с XML и другими языками (скажем, Java)? Мы бы проанализировали\n"
"наши XML файлы со списками дел используя какой-то XML парсер(анализатор), \n"
"написали бы код, который обходит XML дерево и конвертирует его в структуру\n"
"данных Java (потому что, обработка DOM на Java это кость в горле), а затем\n"
"использовали бы эту структуру данных для отображения данных. Теперь, как бы\n"
"мы сделали тоже самое в Лиспе?\n"
"</p>"

#: in/NatureOfLisp.htm:1104
msgid ""
"<p>If we were to adopt the same approach we'd parse the files using Lisp\n"
"\t\t\t\tlibraries responsible for parsing XML. The XML would then be "
"presented\n"
"\t\t\t\tto us as a Lisp list (an s-expression) and we'd walk the list and\n"
"\t\t\t\tpresent relevant data to the user. Of course if we used Lisp it "
"would\n"
"\t\t\t\tmake sense to persist the data as s-expressions directly as there's "
"no\n"
"\t\t\t\treason to do an XML conversion. We wouldn't need special parsing\n"
"\t\t\t\tlibraries since data persisted as a set of s-expressions is valid "
"Lisp and we\n"
"\t\t\t\tcould use Lisp compiler to parse it and store it in memory as a "
"Lisp\n"
"\t\t\t\tlist. Note that Lisp compiler (much like .NET compiler) is "
"available\n"
"\t\t\t\tto a Lisp program at runtime.</p>"
msgstr ""
"<p>\n"
"Если бы мы приняли тот же подход, мы бы анализировали файлы используя "
"библиотеки\n"
"Лисп, отвечающие за синтаксический анализ XML. Затем XML будет представлен "
"нам\n"
"как список Лисп (как s-выражение) и мы пройдемся по списку и представим "
"соответствующие\n"
"данные пользователю. Конечно, если бы мы использовали Лисп, было бы "
"целесообразно\n"
"хранить данные напрямую в виде s-выражений, поскольку нет смысла делать "
"преобразования\n"
"в XML. Нам не понадобятся специальные библиотеки синтаксического анализа, "
"поскольку данные,\n"
"сохраняемые в виде набора s-выражений, являются допустимыми для Лиспа и мы "
"могли бы использовать\n"
"компилятор Лиспа(прим. переводчика: обычный читатель лисп выражений - read, "
"это еще не компилятор лиспа)\n"
"для их анализа и сохранения в памяти в виде Лисп списка. Обратите внимание, "
"что компилятор\n"
"Лиспа(очень похожий на компилятор .NET) доступен для Лисп программы во время "
"выполнения.\n"
"</p>"

#: in/NatureOfLisp.htm:1111
msgid ""
"<p>But we can do better. Instead of writing code to walk the s-expression\n"
"\t\t\t\tthat stores our data we could write a macro that allows us to treat\n"
"\t\t\t\tdata as code! How do macros work? Pretty simple, really. Recall that "
"a\n"
"\t\t\t\tLisp function is called like this:</p>"
msgstr ""
"<p>\n"
"Но мы можем сделать лучше! Вместо написания кода, для обхода s-выражений,\n"
"в которых хранятся наши данные, мы могли бы написать макрос, котоырй "
"позволит\n"
"нам обрабатывать данные как код! Как работают макросы? По правде, довольно "
"просто.\n"
"Напомним, что функция лисп вызывается так:\n"
"</p>"

#: in/NatureOfLisp.htm:1115
msgid ""
"<pre>(function-name arg1 arg2 arg3)\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1121
msgid ""
"<p>Where each argument is a valid Lisp expression that's evaluated and\n"
"\t\t\t\tpassed to the function. For example if we replace <em>arg1</em> "
"above with <em>(+ 4\n"
"\t\t\t\t5)</em>, it will be evaluated and <em>9</em> would be passed to the "
"function. A\n"
"\t\t\t\tmacro works the same way as a function, except its arguments are "
"not\n"
"\t\t\t\tevaluated.</p>"
msgstr ""
"<p>\n"
"Где каждый аргумент является допустимым выражением Лисп, которое "
"вычисляется\n"
"и передается фунции. Например, если мы заменим  <em>arg1</em> выше на <em>(+ "
"4 5)</em>, \n"
"оно будет вычислено и  <em>9</em>  будет передано функции. Макрос работает "
"также как\n"
"и функция, за исключением того, что его аргументы не вычисляются.\n"
"</p>"

#: in/NatureOfLisp.htm:1125
msgid ""
"<pre>(macro-name (+ 4 5))\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1132
msgid ""
"<p>In this case, (+ 4 5) is not evaluated and is passed to the macro as a\n"
"\t\t\t\tlist. The macro is then free to do what it likes with it, including\n"
"\t\t\t\tevaluating it. The return value of a macro is a Lisp list that's\n"
"\t\t\t\ttreated as code. The original place with the macro is replaced with\n"
"\t\t\t\tthis code. For example, we could define a macro plus that takes two\n"
"\t\t\t\targuments and puts in the code that adds them.</p>"
msgstr ""
"<p>В этом случае (+ 4 5) не вычисляется и передается макросу в виде списка. "
"Макрос может свободно\n"
"делать с этим списком, все что ему нравится, включая и его вычисление. "
"Возвращаемое макросом значение -\n"
"это список Лисп, который рассматривается как код. Исходное место с макросом, "
"заменяется этим кодом.\n"
"Например, мы могли бы определить макрос plus, который принимает два "
"аргумента и добавляет код,\n"
"который их складывает.\n"
"</p>"

#: in/NatureOfLisp.htm:1140
msgid ""
"<p>What does it have to do with metaprogramming and our to-do list problem?\n"
"\t\t\t\tWell, for one, macros are little bits of code that generate code "
"using\n"
"\t\t\t\ta list abstraction. Also, we could create macros named <em>to-do</"
"em> and <em>item</em> that\n"
"\t\t\t\treplace our data with whatever code we like, for instance code that\n"
"\t\t\t\tdisplays the item to the user.</p>"
msgstr ""
"<p>\n"
"Какое это отношение имеет к метапрограммированию и нашей проблеме со списком "
"дел?\n"
"Ну, во первых, макросы это маленькие кусочки кода, которые генерируют код, "
"используя\n"
"абстракцию списка. Кроме того, мы могли бы создать макросы с именем <em>to-"
"do</em> и\n"
"<em>item</em>, которые заменяют наши данные любым кодом, который нам "
"нравиться, например\n"
"который отображает элемент пользователю.\n"
"</p>"

#: in/NatureOfLisp.htm:1147
msgid ""
"<p>What benefits does this approach offer? We don't have to walk the list.\n"
"\t\t\t\tThe compiler will do it for us and will invoke appropriate macros. "
"All\n"
"\t\t\t\twe need to do is create the macros that convert our data to\n"
"\t\t\t\tappropriate code!</p>"
msgstr ""
"<p>\n"
"Какие преимущества предлагает этот подход? Нам не нужно проходить по "
"списку.\n"
"Компилятор сделает это за нас и вызовет соответствующие макросы.  Всё, что\n"
"нам нужно сделать, это создать макросы, которые преобразуют наши данные в\n"
"соответствующий код!\n"
"</p>"

#: in/NatureOfLisp.htm:1152
msgid ""
"<p>For example, a macro similar to our <em>triple</em> C macro we showed "
"earlier\n"
"\t\t\t\tlooks like this:</p>"
msgstr ""
"<p>Например, макрос, похожий на наш Си макрос <em>triple</em> , который мы\n"
"продемонстрировали ранее, выглядит так:</p>"

#: in/NatureOfLisp.htm:1157
msgid ""
"<pre>(defmacro triple (x)\n"
"    '(+ ~x ~x ~x))\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1160
msgid ""
"<p>The quote prevents evaluation while the tilde allows it. Now every\n"
"\t\t\t\ttime <em>triple</em> is encountered in lisp code:</p>"
msgstr ""
"<p>Знак цитирования(quote) препятствует вычислению списка, в то время как "
"тильда его\n"
"разрешает. Теперь каждый раз, когда встретиться <em>triple</em> в Лисп "
"коде:\n"
"</p>"

#: in/NatureOfLisp.htm:1164
msgid ""
"<pre>(triple 4)\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1166
msgid "<p>it is replaced with the following code:</p>"
msgstr ""
"<p>\n"
"оно заменится следующим кодом:\n"
"</p>"

#: in/NatureOfLisp.htm:1170
msgid ""
"<pre>(+ 4 4 4)\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1175
msgid ""
"<p>We can create macros for our to-do list items that will get called by\n"
"\t\t\t\tlisp compiler and will transform the to-do list into code. Now our "
"to-do\n"
"\t\t\t\tlist will be treated as code and will be executed. Suppose all we "
"want to do\n"
"\t\t\t\tis print it to standard output for the user to read:</p>"
msgstr ""
"<p>\n"
"Мы можем создать макрос для наших элементов(items) списка дел, который "
"будет \n"
"вызываться компилятором Лиспа и преобразовывать список дел в код. Теперь "
"наш\n"
"список дел будет рассматриваться как код и будет выполнен. Предположим, что\n"
"все что мы хотим, это распечатать его в стандартный вывод, чтобы "
"пользователь\n"
"мог его прочитать:\n"
"</p>"

#: in/NatureOfLisp.htm:1183
msgid ""
"<pre>(defmacro item (priority note)\n"
"    '(block\n"
"         (print stdout tab \"Priority: \"\n"
"             ~(head (tail priority)) endl)\n"
"         (print stdout tab \"Note: \" ~note endl endl)))\n"
"</pre>"
msgstr ""

#: in/NatureOfLisp.htm:1187
msgid ""
"<p>We've just created a very small and limited language for managing to-do "
"lists\n"
"\t\t\t\tembedded in Lisp. Such languages are very specific to a particular "
"problem domain\n"
"\t\t\t\tand are often referred to as domain specific languages or <em>DSLs</"
"em>.</p>"
msgstr ""
"<p>\n"
"Мы только что создали очень маленький и ограниченный язык для управления\n"
"списком дел, встроенный в Лисп. Такие языки очень специфичны для конкретной\n"
"проблемной области и часто называются предметно(доменно) ориентированными\n"
"языками или <em>DSL</em>.\n"
"</p>"

#: in/NatureOfLisp.htm:1194
msgid ""
"\t\t\t\t<h2><a id=\"part_10\">Domain Specific Languages</a></h2>\n"
"\t\t\t\t<p class=\"first\">In this article we've already encountered two "
"domain specific languages: Ant\n"
"\t\t\t\t(specific to dealing with project builds) and our unnamed mini-"
"language for dealing with to-do\n"
"\t\t\t\tlists. The difference is that Ant was written from scratch using "
"XML, an XML parser, and Java while\n"
"\t\t\t\tour language is embedded into Lisp and is easily created within a "
"couple of minutes.</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_10\">Предметно-Ориентированные Языки(Domain "
"Specific Languages)</a></h2>\n"
"\t\t\t\t<p class=\"first\">В этой статье мы уже сталкивались с двумя "
"предметно\n"
"ориентированными языками: Ant(специфичным для работы с построением проектов) "
"и нашим безымянным\n"
"мини-языком для работы со списком дел. Разница в том, что Ant был написан с "
"нуля с использованием XML,\n"
"синтаксического анализатора XML, и Java, в то время как наш язык встроен в "
"Лисп и легко создается\n"
"в течении нескольких минут.\n"
"</p>"

#: in/NatureOfLisp.htm:1204
msgid ""
"<p>We've already discussed the benefits of DSLs, mainly why Ant is using "
"XML, not Java source code.\n"
"\t\t\t\tLisp lets us create as many DSLs as we need for our problem. We can "
"create domain specific languages\n"
"\t\t\t\tfor creating web applications, writing massively multiplayer games, "
"doing fixed income trading,\n"
"\t\t\t\tsolving the protein folding problem, dealing with transactions, etc. "
"We can layer these languages on\n"
"\t\t\t\ttop of each other and create a language for writing web-based "
"trading applications by taking advantage\n"
"\t\t\t\tof our web application language and bond trading language. Every day "
"we'd reap the benefits of\n"
"\t\t\t\tthis approach, much like we reap the benefits of Ant.</p>"
msgstr ""
"<p>\n"
"Мы уже обсуждали преимущества DSLs, главным образом, почему Ant использует "
"XML, \n"
"а не исходный код Java. Лисп позволяет нам создавать столько DSLs, сколько "
"нам\n"
"нужно для нашей проблемы. Мы можем создавать доменно ориентированные языки "
"для\n"
"создания веб-приложений, писать многопользовательские игры, заниматься "
"торговлей\n"
"с фиксированным доходом, решать проблему свертывания белка, заниматься "
"транзакциями\n"
"и т.д. Мы можем наложить эти языки друг на друга и создать язык для "
"написания\n"
"веб-торговых приложений, используя преимущества нашего языка веб-приложений "
"и\n"
"языка торговли облигациями. Каждый день мы пожинали бы плоды этого подхода,\n"
"также как мы пожинаем плоды создания Ant.\n"
"</p>"

#: in/NatureOfLisp.htm:1213
msgid ""
"<p>Using DSLs to solve problems results in much more compact, maintainable, "
"flexible programs. In\n"
"\t\t\t\ta way we create them in Java by creating classes that help us solve "
"the problem. The difference\n"
"\t\t\t\tis that Lisp allows us to take this abstraction to the next level: "
"we're not limited by Java's parser.\n"
"\t\t\t\tThink of writing build scripts in Java itself using some supporting "
"library. Compare it to using Ant.\n"
"\t\t\t\tNow apply this same comparison to every single problem you've ever "
"worked on and you'll begin\n"
"\t\t\t\tto glimpse a small share of the benefits offered by Lisp.</p>"
msgstr ""
"<p>\n"
"Использование DSLs для решения проблем приводит к гораздо более компактным,\n"
"сопровождаемым и гибким программам. В некотором смысле мы создаем их в Java\n"
"создавая классы, которые помогают нам решить эту проблему. Разница в том,\n"
"что Лисп позволяет вывести эту абстракцию на новый уровень: мы не "
"ограничены\n"
"синтаксическим анализатором Java. Подумайте о написании сценариев сборки на\n"
"самом Java используя некоторую вспомогательную библиотеку. Сравните это\n"
"с использованием Ant.\n"
"Теперь примените это же сравнение к каждой отдельной проблеме, над которой\n"
"вы когда-либо работали, и вы начнете видеть небольшую долю преимуществ, \n"
"предлагаемых Лиспом.\n"
"</p>"

#: in/NatureOfLisp.htm:1222
msgid ""
"\t\t\t\t<h2><a id=\"part_11\">What's next?</a></h2>\n"
"\t\t\t\t<p class=\"first\">\n"
"\t\t\t\tLearning Lisp is an uphill battle. Even though in Computer Science "
"terms Lisp is an ancient language,\n"
"\t\t\t\tfew people to date figured out how to teach it well enough\n"
"\t\t\t\tto make it accessible. Despite great efforts by many Lisp "
"advocates, \n"
"\t\t\t\tlearning Lisp today is still hard. The good news is that this won't "
"remain the case forever\n"
"\t\t\t\tsince the amount of Lisp-related resources is rapidly increasing. "
"Time is on Lisp's side.</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_11\">Что дальше?</a></h2>\n"
"\t\t\t\t<p class=\"first\">\n"
"Обучение Лиспу - это тяжелая битва. Несмотря на то, что в терминах "
"компьютерных наук\n"
"Лисп - это древний язык, мало кто на сегодняшний день понял, как преподавать "
"его на\n"
"хорошем уровне, чтобы сделать его доступным. Несмотря на огромные усилия "
"многих\n"
"сторонников Лиспа, изучение Лиспа на сегодня, все еще очень трудно. Хорошая "
"новость\n"
"заключается в том, что это не останется таковым навсегда, поскольку "
"количество ресурсов,\n"
"связанных с Лисп, быстро растет. Время на стороне Лиспа.\n"
"</p>"

#: in/NatureOfLisp.htm:1231
msgid ""
"<p>Lisp is a way to escape mediocrity and to get ahead of the pack. Learning "
"Lisp\n"
"\t\t\t\tmeans you can get a better job today, because you can impress any "
"reasonably intelligent interviewer\n"
"\t\t\t\twith fresh insight into most aspects of software engineering. It "
"also means\n"
"\t\t\t\tyou're likely to get fired tomorrow because everyone is tired of you "
"constantly mentioning how much better\n"
"\t\t\t\tthe company could be doing if only its software was written in Lisp. "
"Is it worth the effort? Everyone who has ever\n"
"\t\t\t\tlearned Lisp says yes. The choice, of course, remains yours.</p>"
msgstr ""
"<p>\n"
"Лисп это способ избежать посредственности и опередить стаю. Изучение Лиспа "
"означает,\n"
"что вы можете получить лучшую работу сегодня, потому что вы можете "
"произвести впечатление\n"
"на любого достаточно умного интервьюера свежим пониманием большинства "
"аспектов разработки\n"
"программного обеспечения. Это также означает, что вас, скорее всего, уволят "
"завтра, потому\n"
"что все устали от того, что вы постоянно упоминаете, насколько лучше могла "
"бы работать\n"
"компания, если бы ее программное обеспечние было написано на Лиспе. Стоит ли "
"это таких\n"
"усилий? Все, кто когда-либо учился программировать на Лиспе, говорят \"ДА\". "
"Выбор, конечно\n"
"остается за вами.\n"
"</p>"

#: in/NatureOfLisp.htm:1237
msgid ""
"\t\t\t\t<h2><a id=\"part_12\">Comments?</a></h2>\n"
"\t\t\t\t<p class=\"first\">Whew. That's enough. I've been writing this "
"article, on and off, for months. If you find it interesting,\n"
"\t\t\t\thave any questions, comments, or suggestions, please drop a note at "
"<a href=\"mailto:coffeemug@gmail.com\">coffeemug@gmail.com</a>.\n"
"\t\t\t\tI'll be glad to hear your feedback.</p>"
msgstr ""
"\t\t\t\t<h2><a id=\"part_12\">Комментарии?</a></h2>\n"
"\t\t\t\t<p class=\"first\">Вот как то так. И этого достаточно. Я писал эту\n"
"статью в течении нескольких месяцев. Если вы находите её интересной, у вас "
"есть какие-либо вопросы,\n"
"комментарии или предложения, пожалуйста напишите мне по адресук \n"
"<a href=\"mailto:coffeemug@gmail.com\">coffeemug@gmail.com</a>.\n"
"Я буду рад услышать ваши отзывы.</p>"

#: in/NatureOfLisp.htm:1240
msgid "\t\t\t\t<div id=\"footnotes\">"
msgstr ""

#: in/NatureOfLisp.htm:1243
msgid ""
"<p><sup><a id=\"note-james\">1</a></sup>I have never met James, nor does he "
"know about my existence. The story is entirely fictional and is based on\n"
"\t\t\t\t\t\ta few postings about Ant's history I found on the internet.</p>"
msgstr ""
"<p><sup><a id=\"note-james\">1</a></sup>Я никогда не встречался с Джеймсом, "
"и он не знает о\n"
"моем существовании. Эта история полностью вымышлена и основана на "
"нескольких\n"
"публикациях об истории Ant, которые я нашел в интернете.</p>"

#: in/NatureOfLisp.htm:1256
msgid ""
"<p><sup><a id=\"note-blaise\">2</a></sup>Lisp has many different \n"
"dialects (the most popular of which are Common Lisp and Scheme). Each \n"
"dialect deals\n"
"\t\t\t\t\t\twith intricate details differently yet shares the same set of \n"
"basic principles. Since the goal of this article is to give you an \n"
"understanding of Lisp's\n"
"\t\t\t\t\t\tprinciples I will use Blaise for examples (which at the time "
"of \n"
"this writing is vaporware). With some minor modifications these examples\n"
" can be translated\n"
"\t\t\t\t\t\tto other Lisp dialects.</p>"
msgstr ""
"<p><sup><a id=\"note-blaise\">2</a></sup>Lisp имеет много различных "
"диалектов\n"
"(наиболее популярными являются Common Lisp и Scheme). Каждый диалект имеет "
"дело\n"
"с запутанными деталями по разному, но разделяет один и тот же набор "
"основных\n"
"принципов. Поскольку цель этой статьи - дать вам понимание принципов Лисп, я "
"буду\n"
"использовать Blaise для примеров (который на момент написания этой статьи "
"являлся\n"
"vaporware). С некоторыми незначительными изменениями эти примеры могут быть "
"переведены\n"
"на другие диалекты Лиспа.</p>"

#: in/NatureOfLisp.htm:1264
msgid ""
"\t\t\t\t</div>\n"
"\t\t\t</div>\n"
"\t\t</div>\n"
"\t\t<div id=\"page-extra-4\"><div id=\"page-extra-5\"><div id=\"page-"
"extra-6\">&nbsp;</div></div></div>\n"
"\t\t</div></div></div>\n"
"\t\t<div id=\"footer\">"
msgstr ""

#: in/NatureOfLisp.htm:1267
msgid ""
"<p>Everything on this site is in public domain unless stated otherwise.<br>\n"
"\t\t\tContact me with any questions or comments at <a href=\"mailto:"
"coffeemug@gmail.com\">coffeemug@gmail.com</a>.</p>"
msgstr ""
"<p>Все, что находится на этом сайте, является общественным достоянием, если "
"не указано\n"
"иное.<br>\n"
"Мои контакты для вопросов и комментариев, через \n"
"<a href=\"mailto:coffeemug@gmail.com\">coffeemug@gmail.com</a>.</p>"

#: in/NatureOfLisp.htm:1274
msgid ""
"\t\t\t<img src=\"../images/valid-xhtml11.png\" alt=\"Valid XHTML 1.1\">\n"
"\t\t\t<img src=\"../images/valid-css.png\" alt=\"Valid CSS\">\n"
"\t\t\t<img src=\"../images/valid-rss.png\" alt=\"Valid RSS\">\n"
"\t\t</div>\n"
"\t\t</div>"
msgstr ""

#: in/NatureOfLisp.htm:1276
msgid "</body></html>"
msgstr ""
